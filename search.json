[{"title":"Hello World","url":"/2024/11/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"算法合集","url":"/2024/11/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/","content":"算法合集\n数组相向双指针解多数之和：\n例：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        Arrays.sort(nums);        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        int n = nums.length;        for(int i = 0;i&lt;n-2;i++)&#123;            int x = nums[i];            if(i&gt;0 &amp;&amp; x==nums[i-1]) continue; //除去重复元素            if(x+nums[i+1]+nums[i+2]&gt;0) break;             if(x+nums[n-2]+nums[n-1]&lt;0) continue;            int j = i+1;            int k = n-1;            while(j&lt;k)&#123;                int s = x+nums[j]+nums[k];                if(s&gt;0) k--;                else if(s&lt;0) j++;                else&#123;                    ans.add(List.of(x,nums[j],nums[k]));                    for(j++;j&lt;k &amp;&amp; nums[j] == nums[j-1];j++);                    for(k--;k&gt;j &amp;&amp; nums[k]==nums[k+1];k--);//跳过重复数字                &#125;            &#125;        &#125;        return ans;    &#125;&#125;\n\n这里由于将数组排过序，可以利用排序后的顺序性质优化代码：\n利用双指针变量j,k 分别指向i+1和n-1,即数组的两端 \n当j下标元素加k下标元素大于0时，证明k下标元素和前面任意元素相加都大于0，故要让k自减\n当和小于0时，证明j下标元素和后面任意元素相加都小于0，故要让j自增，找更大的元素\n\n\n优化：\nif(x+nums[i+1]+nums[i+2]&gt;0) break;\n//这里当i下标元素加上离该元素最近的两个元素时和大于0，证明i下标后面的元素相加都会大于0，可以直接退出循环\n2. ```java   if(x+nums[n-2]+nums[n-1]&lt;0) continue;   //当i下标元素与数组最大的两个元素相加时小于0，证明i下标元素与后面元素相加都小于0，故可以跳过此次循环\n\n\nfor(j++;j&lt;k &amp;&amp; nums[j] == nums[j-1];j++);\nfor(k--;k&gt;j &amp;&amp; nums[k]==nums[k+1];k--);\n\n//这里用于跳过数组中重复的数字\n\n  - ### 同类型题解：四数之和  给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：  - `0 &lt;= a, b, c, d &lt; n`  - `a`、`b`、`c` 和 `d` **互不相同**  - `nums[a] + nums[b] + nums[c] + nums[d] == target`  ```java  class Solution &#123;      public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;          Arrays.sort(nums);          int l = nums.length;          List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();          for(int i = 0;i&lt;l-3;i++)&#123;//枚举第一个数              long x = nums[i];              if(i&gt;0 &amp;&amp; x == nums[i-1]) continue;              if((x+nums[i+1]+nums[i+2]+nums[i+3])&gt;target) break;              if((x+nums[l-1]+nums[l-2]+nums[l-3])&lt;target) continue;              for(int b = i+1;b&lt;l-2;b++)&#123; //这里与外层代码同理，枚举下一个元素                  long y = nums[b];                  if(b&gt;i+1 &amp;&amp; y == nums[b-1]) continue;                  if((x+y+nums[b+1]+nums[b+2])&gt;target) break;                  if((x+y+nums[l-1]+nums[l-2])&lt;target) continue;                  int c = b+1;                  int d = l-1;                  while(c&lt;d)&#123;//枚举第三第四个数                      long s = x + y + nums[c] + nums[d];                      if(s&lt;target) c++;                      else if(s&gt;target) d--;                      else&#123;                          ans.add(List.of((int)x,(int)y,nums[c],nums[d]));                          for(c++;c&lt;d &amp;&amp; nums[c] == nums[c-1];c++);                          for(d--;d&gt;c &amp;&amp; nums[d] == nums[d+1];d--);                      &#125;                  &#125;              &#125;          &#125;          return ans;      &#125;  &#125;\n\n\n\n由此可见，双指针法可以简化两个数的和，无法简化两个数以上的和，因此需要多循环枚举来遍历所有数字\n\n\n滑动窗口：长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 \n子数组\n[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n代码实现：class Solution &#123;    public int minSubArrayLen(int target, int[] nums) &#123;        int n = nums.length;        int ans = n+1;        int sum = 0;//子数组元素和        int left = 0;//子数组左端点        for(int right = 0;right&lt;n;right++)&#123;            sum+=nums[right];            while(sum&gt;=target)&#123;                ans = Math.min(ans,right-left+1);                sum-=nums[left++];//左端点右移            &#125;        &#125;        return ans&lt;=n ? ans : 0;    &#125;&#125;\n\n\n二分查找:在排序数组中查找元素的第一个和最后一个位置给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n这里的所有查找都是找到nums数组中&#x3D;&#x3D;大于等于target&#x3D;&#x3D;的第一个下标位置   // 闭区间写法,即目标下标在闭区间内private int lowerBound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1; // 闭区间 [left, right]    while (left &lt;= right) &#123; // 区间不为空        // 循环不变量：        // nums[left-1] &lt; target        // nums[right+1] &gt;= target        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            //这里需要保证范围始终包含目标值，即区间一定得是闭区间的            left = mid + 1; // 范围缩小到 [mid+1, right]        &#125; else &#123;            right = mid - 1; // 范围缩小到 [left, mid-1]        &#125;    &#125;    return left;&#125;   // 左闭右开区间写法，即目标下标在左闭右开的区间内private int lowerBound2(int[] nums, int target) &#123;    int left = 0, right = nums.length; // 左闭右开区间 [left, right)    while (left &lt; right) &#123; // 区间不为空        // 循环不变量：        // nums[left-1] &lt; target        // nums[right] &gt;= target        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid + 1; // 范围缩小到 [mid+1, right)        &#125; else &#123;            right = mid; // 范围缩小到 [left, mid)        &#125;    &#125;    return left; // 返回 left 还是 right 都行，因为循环结束后 left == right&#125;   // 开区间写法,即目标区间在开区间内private int lowerBound3(int[] nums, int target) &#123;    int left = -1, right = nums.length; // 开区间 (left, right)    while (left + 1 &lt; right) &#123; // 区间不为空        // 循环不变量：        // nums[left] &lt; target        // nums[right] &gt;= target        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid; // 范围缩小到 (mid, right)        &#125; else &#123;            right = mid; // 范围缩小到 (left, mid)        &#125;    &#125;    return right;&#125;   \n\n其他查找条件：\n找到大于target的第一个下标位置：即找到第一个大于等于target+1的位置\n找到小于target的第一个下标位置：即找到大于等于target的上一个位置\n找到小于等于target的第一个下标位置：即找到大于target的上一个位置\n\n\n反转链表给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\nclass Solution &#123;    public ListNode reverseKGroup(ListNode head, int k) &#123;        int len = 0;        ListNode p = head;        while(p!=null)&#123;            p=p.next;            len++;        &#125;        if(len&lt;k)&#123;            return head;        &#125;        ListNode dummy = new ListNode(0,head); //作为反转链表的前一个节点，辅助反转        ListNode p0 = dummy;        ListNode pre = null;        ListNode cur =head;                for(;len&gt;=k;len-=k)&#123;            for(int i = 0;i&lt;k;i++)&#123;                ListNode nxt = cur.next;                cur.next = pre;                pre = cur;                cur = nxt;            &#125;            ListNode nxt = p0.next;//保存下一个要反转的节点的前一个结点            p0.next.next = cur;            p0.next = pre;            p0  =  nxt;        &#125;        return dummy.next;    &#125;&#125;\n\n使用dummyNode,p0指针，令链表反转\n\n快慢指针用于解决链表相关问题,例：在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;= i &lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。\n比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。\n\n孪生和 定义为一个节点和它孪生节点两者值之和。\n给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。\nclass Solution &#123;    public int pairSum(ListNode head) &#123;        //先找到中间结点        ListNode mid = findMid(head);        //将另一半链表反转        ListNode rl = reverseList(mid);        //同时遍历两个链表，求出两个链表节点之和最大值        int max = 0;        while(head!=null &amp;&amp; rl!=null)&#123;            max = Math.max(head.val+rl.val,max);            head = head.next;            rl = rl.next;        &#125;        return max;    &#125;    //利用快慢指针找到链表中间节点    public ListNode findMid(ListNode head)&#123;        ListNode slow = head,fast = head;        while(fast!=null &amp;&amp; fast.next!=null)&#123;            slow = slow.next;            fast = fast.next.next;        &#125;        return slow;    &#125;    //利用临时变量存储下一个节点信息来反转链表    public ListNode reverseList(ListNode head)&#123;        ListNode cur = head,pre = null;        while(cur!=null)&#123;            ListNode nxt = cur.next;            cur.next = pre;            pre = cur;            cur = nxt;        &#125;        return pre;    &#125;&#125;\n\n删除链表重复节点只要&#x3D;&#x3D;涉及删除头结点&#x3D;&#x3D;的操作，大多需要初始化一个dummyNode协助操作有一个单链表的 head，我们想删除它其中的一个节点 node。\n给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。\n链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。\n删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：\n\n给定节点的值不应该存在于链表中。\n链表中的节点数应该减少 1。\nnode 前面的所有值顺序相同。\nnode 后面的所有值顺序相同。\n\nclass Solution &#123;    public void deleteNode(ListNode node) &#123;        node.val = node.next.val;        node.next = node.next.next;    &#125;&#125;\n\n这里只需要将该节点的值修改为下一节点的值，并让该节点的next指针指向下下个节点即可。例2：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(0,head);//可能会删除头结点，故新建dummy节点        ListNode left = dummy;        ListNode right = dummy;        while(n-- &gt; 0)&#123;            right = right.next;        &#125;        while(right.next!=null)&#123;            left = left.next;            right = right.next;        &#125;        left.next = left.next.next;        return dummy.next;    &#125;&#125;\n\n例3：删除排序链表中的重复节点给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。\nclass Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        if(head==null||head.next==null) return head;        ListNode cur = head;        while(cur.next!=null)&#123;            if(cur.next.val==cur.val)&#123;                cur.next = cur.next.next;            &#125;else&#123;                cur = cur.next;            &#125;        &#125;        return head;    &#125;&#125;\n\n例4：删除排序链表的所有重复节点给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。\nclass Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        ListNode dummy = new ListNode(0,head);//防止删除头结点情况        ListNode cur = dummy;        while(cur.next!=null &amp;&amp; cur.next.next!=null)&#123;//确保cur后面两个节点存在            int val = cur.next.val;            if(val==cur.next.next.val)&#123;//后两个节点值相同                while(cur.next!=null&amp;&amp;cur.next.val==val)&#123;//循环，删除所有与该值相等的节点                    cur.next = cur.next.next;                &#125;            &#125;else&#123;                cur = cur.next;//值不相同，则将cur向后移动            &#125;        &#125;        return dummy.next;    &#125;&#125;\n\n","categories":["Blog"]}]