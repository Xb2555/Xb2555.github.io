[{"title":"算法合集","url":"/2024/11/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/","content":"算法合集\n数组相向双指针解多数之和：\n例：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        Arrays.sort(nums);        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        int n = nums.length;        for(int i = 0;i&lt;n-2;i++)&#123;            int x = nums[i];            if(i&gt;0 &amp;&amp; x==nums[i-1]) continue; //除去重复元素            if(x+nums[i+1]+nums[i+2]&gt;0) break;             if(x+nums[n-2]+nums[n-1]&lt;0) continue;            int j = i+1;            int k = n-1;            while(j&lt;k)&#123;                int s = x+nums[j]+nums[k];                if(s&gt;0) k--;                else if(s&lt;0) j++;                else&#123;                    ans.add(List.of(x,nums[j],nums[k]));                    for(j++;j&lt;k &amp;&amp; nums[j] == nums[j-1];j++);                    for(k--;k&gt;j &amp;&amp; nums[k]==nums[k+1];k--);//跳过重复数字                &#125;            &#125;        &#125;        return ans;    &#125;&#125;\n\n这里由于将数组排过序，可以利用排序后的顺序性质优化代码：\n利用双指针变量j,k 分别指向i+1和n-1,即数组的两端 \n当j下标元素加k下标元素大于0时，证明k下标元素和前面任意元素相加都大于0，故要让k自减\n当和小于0时，证明j下标元素和后面任意元素相加都小于0，故要让j自增，找更大的元素\n\n\n优化：\nif(x+nums[i+1]+nums[i+2]&gt;0) break;\n//这里当i下标元素加上离该元素最近的两个元素时和大于0，证明i下标后面的元素相加都会大于0，可以直接退出循环\n2. ```java   if(x+nums[n-2]+nums[n-1]&lt;0) continue;   //当i下标元素与数组最大的两个元素相加时小于0，证明i下标元素与后面元素相加都小于0，故可以跳过此次循环\n\n\nfor(j++;j&lt;k &amp;&amp; nums[j] == nums[j-1];j++);\nfor(k--;k&gt;j &amp;&amp; nums[k]==nums[k+1];k--);\n\n//这里用于跳过数组中重复的数字\n\n  - ### 同类型题解：四数之和  给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：  - `0 &lt;= a, b, c, d &lt; n`  - `a`、`b`、`c` 和 `d` **互不相同**  - `nums[a] + nums[b] + nums[c] + nums[d] == target`  ```java  class Solution &#123;      public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;          Arrays.sort(nums);          int l = nums.length;          List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();          for(int i = 0;i&lt;l-3;i++)&#123;//枚举第一个数              long x = nums[i];              if(i&gt;0 &amp;&amp; x == nums[i-1]) continue;              if((x+nums[i+1]+nums[i+2]+nums[i+3])&gt;target) break;              if((x+nums[l-1]+nums[l-2]+nums[l-3])&lt;target) continue;              for(int b = i+1;b&lt;l-2;b++)&#123; //这里与外层代码同理，枚举下一个元素                  long y = nums[b];                  if(b&gt;i+1 &amp;&amp; y == nums[b-1]) continue;                  if((x+y+nums[b+1]+nums[b+2])&gt;target) break;                  if((x+y+nums[l-1]+nums[l-2])&lt;target) continue;                  int c = b+1;                  int d = l-1;                  while(c&lt;d)&#123;//枚举第三第四个数                      long s = x + y + nums[c] + nums[d];                      if(s&lt;target) c++;                      else if(s&gt;target) d--;                      else&#123;                          ans.add(List.of((int)x,(int)y,nums[c],nums[d]));                          for(c++;c&lt;d &amp;&amp; nums[c] == nums[c-1];c++);                          for(d--;d&gt;c &amp;&amp; nums[d] == nums[d+1];d--);                      &#125;                  &#125;              &#125;          &#125;          return ans;      &#125;  &#125;\n\n\n\n由此可见，双指针法可以简化两个数的和，无法简化两个数以上的和，因此需要多循环枚举来遍历所有数字\n\n\n滑动窗口：长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 \n子数组\n[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n代码实现：class Solution &#123;    public int minSubArrayLen(int target, int[] nums) &#123;        int n = nums.length;        int ans = n+1;        int sum = 0;//子数组元素和        int left = 0;//子数组左端点        for(int right = 0;right&lt;n;right++)&#123;            sum+=nums[right];            while(sum&gt;=target)&#123;                ans = Math.min(ans,right-left+1);                sum-=nums[left++];//左端点右移            &#125;        &#125;        return ans&lt;=n ? ans : 0;    &#125;&#125;\n\n\n二分查找:在排序数组中查找元素的第一个和最后一个位置给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n这里的所有查找都是找到nums数组中&#x3D;&#x3D;大于等于target&#x3D;&#x3D;的第一个下标位置   // 闭区间写法,即目标下标在闭区间内private int lowerBound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1; // 闭区间 [left, right]    while (left &lt;= right) &#123; // 区间不为空        // 循环不变量：        // nums[left-1] &lt; target        // nums[right+1] &gt;= target        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            //这里需要保证范围始终包含目标值，即区间一定得是闭区间的            left = mid + 1; // 范围缩小到 [mid+1, right]        &#125; else &#123;            right = mid - 1; // 范围缩小到 [left, mid-1]        &#125;    &#125;    return left;&#125;   // 左闭右开区间写法，即目标下标在左闭右开的区间内private int lowerBound2(int[] nums, int target) &#123;    int left = 0, right = nums.length; // 左闭右开区间 [left, right)    while (left &lt; right) &#123; // 区间不为空        // 循环不变量：        // nums[left-1] &lt; target        // nums[right] &gt;= target        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid + 1; // 范围缩小到 [mid+1, right)        &#125; else &#123;            right = mid; // 范围缩小到 [left, mid)        &#125;    &#125;    return left; // 返回 left 还是 right 都行，因为循环结束后 left == right&#125;   // 开区间写法,即目标区间在开区间内private int lowerBound3(int[] nums, int target) &#123;    int left = -1, right = nums.length; // 开区间 (left, right)    while (left + 1 &lt; right) &#123; // 区间不为空        // 循环不变量：        // nums[left] &lt; target        // nums[right] &gt;= target        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid; // 范围缩小到 (mid, right)        &#125; else &#123;            right = mid; // 范围缩小到 (left, mid)        &#125;    &#125;    return right;&#125;   \n\n其他查找条件：\n找到大于target的第一个下标位置：即找到第一个大于等于target+1的位置\n找到小于target的第一个下标位置：即找到大于等于target的上一个位置\n找到小于等于target的第一个下标位置：即找到大于target的上一个位置\n\n\n反转链表给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\nclass Solution &#123;    public ListNode reverseKGroup(ListNode head, int k) &#123;        int len = 0;        ListNode p = head;        while(p!=null)&#123;            p=p.next;            len++;        &#125;        if(len&lt;k)&#123;            return head;        &#125;        ListNode dummy = new ListNode(0,head); //作为反转链表的前一个节点，辅助反转        ListNode p0 = dummy;        ListNode pre = null;        ListNode cur =head;                for(;len&gt;=k;len-=k)&#123;            for(int i = 0;i&lt;k;i++)&#123;                ListNode nxt = cur.next;                cur.next = pre;                pre = cur;                cur = nxt;            &#125;            ListNode nxt = p0.next;//保存下一个要反转的节点的前一个结点            p0.next.next = cur;            p0.next = pre;            p0  =  nxt;        &#125;        return dummy.next;    &#125;&#125;\n\n使用dummyNode,p0指针，令链表反转\n\n快慢指针用于解决链表相关问题,例：在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;= i &lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。\n比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。\n\n孪生和 定义为一个节点和它孪生节点两者值之和。\n给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。\nclass Solution &#123;    public int pairSum(ListNode head) &#123;        //先找到中间结点        ListNode mid = findMid(head);        //将另一半链表反转        ListNode rl = reverseList(mid);        //同时遍历两个链表，求出两个链表节点之和最大值        int max = 0;        while(head!=null &amp;&amp; rl!=null)&#123;            max = Math.max(head.val+rl.val,max);            head = head.next;            rl = rl.next;        &#125;        return max;    &#125;    //利用快慢指针找到链表中间节点    public ListNode findMid(ListNode head)&#123;        ListNode slow = head,fast = head;        while(fast!=null &amp;&amp; fast.next!=null)&#123;            slow = slow.next;            fast = fast.next.next;        &#125;        return slow;    &#125;    //利用临时变量存储下一个节点信息来反转链表    public ListNode reverseList(ListNode head)&#123;        ListNode cur = head,pre = null;        while(cur!=null)&#123;            ListNode nxt = cur.next;            cur.next = pre;            pre = cur;            cur = nxt;        &#125;        return pre;    &#125;&#125;\n\n删除链表重复节点只要&#x3D;&#x3D;涉及删除头结点&#x3D;&#x3D;的操作，大多需要初始化一个dummyNode协助操作有一个单链表的 head，我们想删除它其中的一个节点 node。\n给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。\n链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。\n删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：\n\n给定节点的值不应该存在于链表中。\n链表中的节点数应该减少 1。\nnode 前面的所有值顺序相同。\nnode 后面的所有值顺序相同。\n\nclass Solution &#123;    public void deleteNode(ListNode node) &#123;        node.val = node.next.val;        node.next = node.next.next;    &#125;&#125;\n\n这里只需要将该节点的值修改为下一节点的值，并让该节点的next指针指向下下个节点即可。例2：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\nclass Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(0,head);//可能会删除头结点，故新建dummy节点        ListNode left = dummy;        ListNode right = dummy;        while(n-- &gt; 0)&#123;            right = right.next;        &#125;        while(right.next!=null)&#123;            left = left.next;            right = right.next;        &#125;        left.next = left.next.next;        return dummy.next;    &#125;&#125;\n\n例3：删除排序链表中的重复节点给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。\nclass Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        if(head==null||head.next==null) return head;        ListNode cur = head;        while(cur.next!=null)&#123;            if(cur.next.val==cur.val)&#123;                cur.next = cur.next.next;            &#125;else&#123;                cur = cur.next;            &#125;        &#125;        return head;    &#125;&#125;\n\n例4：删除排序链表的所有重复节点给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。\nclass Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        ListNode dummy = new ListNode(0,head);//防止删除头结点情况        ListNode cur = dummy;        while(cur.next!=null &amp;&amp; cur.next.next!=null)&#123;//确保cur后面两个节点存在            int val = cur.next.val;            if(val==cur.next.next.val)&#123;//后两个节点值相同                while(cur.next!=null&amp;&amp;cur.next.val==val)&#123;//循环，删除所有与该值相等的节点                    cur.next = cur.next.next;                &#125;            &#125;else&#123;                cur = cur.next;//值不相同，则将cur向后移动            &#125;        &#125;        return dummy.next;    &#125;&#125;\n\n","categories":["Blog"]},{"title":"Redis进阶+基础","url":"/2024/11/10/redis/","content":"redis\nredis缓存更新策略:\n主动更新策略:在更新数据的业务中同时更新缓存中数据\nCache Aside Pattern（主要用这个策略）: \n由缓存的调用者，在更新数据库的同时更新缓存\n\n更新缓存策略选删除缓存方案，在更新数据库同时让原来缓存失效\n解决线程安全问题:\n先修改数据库，再删除缓存\n\n\n\n\nRead&#x2F;Write Through Pattern:\n缓存与数据库整合为一个服务，由服务来维护一致性。\n\nWrite Behind Caching Pattern:\n调用者只操作缓存，由其他线程异步将缓存数据持久化到数据库，保持最终一致\n\n\n\n内存淘汰:利用redis的内存淘汰机制，当内存不足时自动淘汰一部分数据\n超时剔除：给缓存数据添加TTL时间，到期自动删除缓存数据，下次查询更新缓存\n\n\n缓存穿透☞客户端请求的数据在缓存和数据库中都不存在，缓存永远不生效解决方案:\n缓存空对象：将null缓存，设置TTL过期时间\n布隆过滤：设置过滤器，前置查询数据是否存在\n\n\n缓存雪崩☞在同一时刻大量的缓存key同时失效或redis服务宕机，导致大量请求到达数据库解决方案:\n给不同key加随机的TTL&#x3D;&#x3D;随机值&#x3D;&#x3D;\n利用redis集群提供服务可用性\n给缓存业务添加降级限流策略\n给业务添加多级缓存\n\n\n缓存击穿：☞一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数请求会给数据库带来压力解决方案:\n逻辑过期:在value中设置过期时间，当有一线程查询到过期数据时，会将更新数据操作交给另一线程，并且获取互斥锁，该锁只会在更新完数据后才释放，若在更新过程中有其他线程访问，获取不到互斥锁，即有线程在进行更新操作，则该线程会直接获取过期的旧数据。互斥锁实现方法：利用redis创建不可修改变量来模拟锁，这时其他线程尝试修改该变量时会返回false，即无法获取锁。\n缺点：不保证一致性，会有额外的内存消耗，实现较为复杂。\n互斥锁解决:\n![屏幕截图 2024-09-23 101811](E:\\桌面\\重要文件\\屏幕截图 2024-09-23 101811-1727169685634-1.png)\n//获取锁的方法，即在redis中创建一个不能被更改的值，当存在该key时，会返回falseprivate boolean tryLock(String key)&#123;    Boolean flag = \t\t     stringRedisTemplate.opsForValue().setIfAbsent(key,&quot;1&quot;,10,TimeUnit.SECONDS);    return BooleanUtil.isTrue(flag);&#125;//释放锁的方法,即删除该锁变量private void unLock(String key)&#123;    stringRedisTemplate.delete(key);&#125;\n\n逻辑过期方式解决：![屏幕截图 2024-09-23 103856](E:\\桌面\\重要文件\\屏幕截图 2024-09-23 103856-1727169696221-3.png)\n创建一个包含expireTime过期时间属性的对象，例如向user对象加入expireTime的属性://先创建一个包含过期时间属性的类public class RedisData&#123;    private LocalDateTime expireTime;    private Object data;//这里的data存放需要封装的对象&#125;//将包含过期时间属性的对象存入redis中public void saveShop(Long id,Long expireTime)&#123;    //1.先查询信息    Shop shop = getByid(id);    //2.封装逻辑过期时间    RedisData redisData = new RedisData();    redisData.setData(shop);    redisData.setExpireTime(LocalDateTime.now.plusSeconds(expireTime));    //3.写入redis    stringRedisTemplate.opsForValue().set(&quot;local:shop:&quot;+id,JSON.toJsonString(redisData));&#125;//创建线程池private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);//获取缓存数据，并判断是否过期public Shop queryWithLogicalExpire(Long id)&#123;    String key = &quot;local:shop:&quot;+id;    //从redis查询缓存    String shopJson = stringRedisTemplate.opsForValue().get(key);    //判断是否存在    if(shopJson==null)&#123;        return null;//不存在，返回null    &#125;    //缓存查找命中，先把json反序列化为对象    RedisData redisData = JSON.parseObject(shopJson,RedisData.class);    JSONObject data = (JSONObject) redisData.getData();//这里拿到的是jsonObject对象    Shop shop = JSON.praseObject(data,Shop.class);    //判断是否过期    if(expireTime.isAfter(LocalDateTime.now()))&#123;        //未过期，返回店铺信息        return shop;    &#125;    //已过期，重建缓存    //缓存重建    //获取互斥锁    String lockKey = &quot;lock:shop:&quot;+id;    boolean isLock = tryLock(lockKey);    //判断获取锁是否成功    if(isLock)&#123;        //成功，则开启独立线程，实现缓存重建        //这里需要再次检测redis缓存是否过期，如果存在则无需重建缓存        //从redis查询缓存    \tshopJson = stringRedisTemplate.opsForValue().get(key);    \t//判断是否存在    \tif(shopJson==null)&#123;        \treturn null;//不存在，返回null    \t&#125;        redisData = JSON.parseObject(shopJson,RedisData.class);    \tdata = (JSONObject) redisData.getData();//这里拿到的是jsonObject对象    \tshop = JSON.praseObject(data,Shop.class);    \t//判断是否过期    \tif(expireTime.isAfter(LocalDateTime.now()))&#123;        \t//未过期，返回店铺信息        \treturn shop;    \t&#125;        //过期，则开启独立线程重建缓存        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;            //调用缓存重建方法            this.saveShop(id,20L);//设置20s的过期时间            //释放锁            unlock(lockKey);        &#125;);    &#125;    //失败，返回过期的商品信息    return shop;&#125;\n\n\n利用redis实现全局唯一ID\n为实现安全性，需要在id中拼接一些其他信息:\n\npublic class RedisIdWorker&#123;\n    private StringRedisTemplate redisTemplate;\n\n    public RedisIdWorker(StringRedisTemplate redisTemplate)&#123;\n        this.redisTemplate = redisTemplate;\n    &#125;\n\n    /**\n     * 开始时间戳，从24/1/1开始\n     */\n    private static final long BEGIN_LOCALTIME = 1704067200L;\n\n    /**\n     * 序列号位数\n     */\n    private static final int COUNT_BITS = 32;\n\n    public long nextId(String keyPrefix)&#123;\n        //生成id\n\n        //1.生成时间戳，计算当前时间戳\n        LocalDateTime now = LocalDateTime.now();\n        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);\n        long timeStamp = nowSecond-BEGIN_LOCALTIME;\n\n        //2.生成序列号\n        //2.1.获取当前日期，精确到天\n        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));\n        //2.2.自增长\n        Long count = redisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);\n        //3.拼接并返回\n        return timeStamp &lt;&lt; COUNT_BITS | count;\n    &#125;\n&#125;\n6. ## 乐观锁解决高并发线程问题   - ### 在更新时判断是否有其他线程在修改数据库   ![image-20240923212224180](E:\\桌面\\重要文件\\image-20240923212224180.png)   ### ==改进：将约束条件换为stock&gt;0==7. ## spring中，某个类调用自身的方法时，若该方法加了事务注解，该事务会失效，需要利用该对象的代理对象才能使用事务。   ```java   public class Test()&#123;       @Transactional       public Result createOrder()&#123;           ...       &#125;              public void test()&#123;           ...           //获取代理对象          \tTest proxy = (Test)AopContext.currentProxy();           //调用代理对象方法           proxy.createOrder();       &#125;   &#125;\n\n\n\n\n基于redis实现分布式锁\n两个基本方法:\n获取锁:#添加锁，利用setnx互斥特性SETNX lock thread1#添加过期时间,避免服务宕机引起的死锁EXPIRE lock 10\n\n互斥，确保只能有一个线程获取锁\n\n释放锁:删除锁即可，需要设置超时释放时间\n\n\n\n代码实现:public class RedisLock implements ILock&#123;    private StringRedisTemplate redisTemplate;    private String lockName;    private static final String KEY_PREFIX = &quot;lock:&quot;;    public RedisLock(StringRedisTemplate redisTemplate)&#123;        this.redisTemplate = redisTemplate;    &#125;    @Override    public boolean tryLock(long timeoutSec) &#123;        //获取线程标识        long threadId = Thread.currentThread().getId();        //获取锁        //这里的threadId为锁标识，用于保证线程始终处理的锁都是一致的        Boolean result = redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + lockName, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);        return Boolean.TRUE.equals(result);//这样若result为空，也会返回false    &#125;    @Override    public void unlock() &#123;        //释放锁        redisTemplate.delete(KEY_PREFIX + lockName);    &#125;&#125;\n\n改进redis分布式锁:\n获取锁时存入线程标识(用UUID表示)\n释放锁时先获取锁中的线程标识，判断是否与当前线程标识一致\n一致则释放锁\n不一致则不释放\n防止由于业务阻塞而误删锁\n代码:\n\npublic class RedisLock implements ILock&#123;\n    private final StringRedisTemplate redisTemplate;\n    private String lockName;\n    private static final String KEY_PREFIX = &quot;lock:&quot;;\n    //获取UUID\n    private static final String ID_PREFIX = UUID.randomUUID().toString(true);\n\n    //加载lua脚本\n    private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;\n    static &#123;\n        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();\n        UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;));\n        UNLOCK_SCRIPT.setResultType(Long.class);\n    &#125;\n\n\n    public RedisLock(StringRedisTemplate redisTemplate)&#123;\n        this.redisTemplate = redisTemplate;\n    &#125;\n\n    @Override\n    public boolean tryLock(long timeoutSec) &#123;\n        //获取线程标识\n        String threadId = ID_PREFIX + Thread.currentThread().getId();\n\n        //获取锁\n        //这里的threadId为锁标识，用于保证线程始终处理的锁都是一致的\n        Boolean result = redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + lockName, threadId, timeoutSec, TimeUnit.SECONDS);\n\n        return Boolean.TRUE.equals(result);//这样若result为空，也会返回false\n    &#125;\n\n    @Override\n    public void unlock() &#123;\n        //使用lua脚本,确保原子性，解决锁的误删\n        redisTemplate.execute(\n                UNLOCK_SCRIPT,\n                Collections.singletonList(KEY_PREFIX+lockName),\n                ID_PREFIX + Thread.currentThread().getId()\n                );\n    &#125;\n&#125;\n- ### redis锁的进一步改进:  - #### 存在问题:    ![image-20240924191053966](E:\\桌面\\重要文件\\image-20240924191053966.png)- ### redisson可重入锁原理  ![image-20240925160643891](E:\\桌面\\重要文件\\image-20240925160643891.png)  ```lua  --使用lua脚本编写获取可重入锁  local key = KEYS[1]  local threadId = ARGV[1]  local releaseTime = ARGV[2]    --判断是否存在  if (redis.call(&#x27;exists&#x27;,key)==0) then      --不存在，获取锁      redis.call(&#x27;hset&#x27;,key,threadId,&#x27;1&#x27;);      --设置有效期      redis.call(&#x27;expire&#x27;,key,releaseTime);      return 1;  end;    --锁已经存在，判断threadId是否是自己  if(redis.call(&#x27;hexists&#x27;,key,threadId)==1) then      --不存在，获取锁，重入次数加一      redis.call(&#x27;hincrby&#x27;,key,threadId,&#x27;1&#x27;);      --设置有效期      redis.call(&#x27;expire&#x27;,key,releaseTime);      return 1;  end;  return 0;--表示获取的锁不是自己，获取锁失败      --使用lua脚本释放可重入锁    --判断当前锁释放还被自己持有  if(redis.call(&#x27;HEXISTS&#x27;,key,threadId)==0) then      return nil;  end;  --是自己的锁则重入次数减一  local count = redis.call(&#x27;HINCRBY&#x27;,key, threadId, -1);  --判断是否重入次数  if(count&gt;0) then      --大于零说明不能释放锁，重置有效期后返回      redis.call(&#x27;expire&#x27;,key,releaseTime);      return nil;  else --等于0说明可以释放锁，直接删除      redis.call(&#x27;del&#x27;,key);      return nil;  end;\n\n\n\n\n\n\n主从搭建：\n主从数据同步原理：数据同步有两种方式：全量同步与增量同步replicationID:每一个master节点都有自己唯一的id，简称replid。当slaver节点尝试同步master数据时，master会将自己的id发给slaver，当slaver尝试同步数据时，master会通过它的id与自己的id比较来判断是否为第一次同步数据offset:repl_backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致\n\n优化全量同步：\n在master中配置repl-diskless-sync yes 启用无磁盘复制\nredis单节点内存不要过大\n适当提高repl_baklog的大小，发项slave宕机时尽快实现故障恢复，尽可能避免全量同步\n限制一个master上的slaver数量，若数量过多，可采用主-从-从链式结构，减少master压力\n\n\n哨兵原理redis中的哨兵集群的作用：\n监控：监测master和slaver是否正常工作\n自动故障切换：若master故障，哨兵会把一个slaver自动提升为master，原来的master故障恢复也会变为新master的slaver\n通知：当集群发生故障转移时，哨兵会将最新节点信息推送给redis客户端\n\n监控原理：利用心跳检测机制，每1秒向集群每个实例发送ping命令\n\n选举新的master机制：\n实现故障转移：\n\n搭建分片集群\n用于解决的问题：海量数据存储问题高并发写的问题\n集群特征：集群中有多个master，用于保存不同数据每个master都可以有多个slave节点master之间可以互相ping监测彼此健康状态\n\n\nRedisObject\n\nSkipList:本质上是链表，但与传统链表有些差异：\n元素按照升序排序存储\n节点可能包含多层指针，指针跨度不同\n增删改效率与红黑树基本一致，实现更简单\n\n\nSortedSet特点：\n每组数据都包含score和member\nmember唯一\n可依据score排序\n\n底层数据结构：\n底层有一个哈希表用于&#x3D;&#x3D;用member查询score&#x3D;&#x3D;，还有一个skipset用于&#x3D;&#x3D;使用score查询member&#x3D;&#x3D;\n由于需要用score来进行排序，因此底层有维护一个跳表\n\n\n过期KEY处理原理redis所有数据存放在redisDb结构体中，其中包含两个哈希表：\ndict：保存redis中所有键值对\nexpires：保存redis中所有设置了过期时间的key及其到期时间(&#x3D;&#x3D;写入时间+TTL&#x3D;&#x3D;)\n\n过期key的延时删除策略：\n惰性删除：每当需要对该key操作时，会判断该key的存活时间，已经过期了才执行删除\n周期删除：通过定时任务，周期性的抽样部分有TTL的key，若过期则删除\n\n\n内存淘汰策略当redis内存使用达到设置阈值时，会主动挑选部分key删除以释放更多内存\n推荐使用带&#x3D;&#x3D;volatile&#x3D;&#x3D;的过期机制，这样将淘汰限制在只对设置了TTL的key推荐使用带&#x3D;&#x3D;LFU&#x3D;&#x3D;的算法，这样会减少误淘汰重要数据\n\n\n\n\n\n\n","categories":["Blog"]}]