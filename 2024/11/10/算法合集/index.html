<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>算法合集 | 徐博的博客</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>算法合集</h1></div><hr><div id="post-content"><h1 id="算法合集"><a href="#算法合集" class="headerlink" title="算法合集"></a>算法合集</h1><ol>
<li><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="相向双指针解多数之和："><a href="#相向双指针解多数之和：" class="headerlink" title="相向双指针解多数之和："></a>相向双指针解多数之和：</h3><ul>
<li><h3 id="例：给你一个长度为-n-的整数数组-nums-和-一个目标值-target。请你从-nums-中选出三个整数，使它们的和与-target-最接近。"><a href="#例：给你一个长度为-n-的整数数组-nums-和-一个目标值-target。请你从-nums-中选出三个整数，使它们的和与-target-最接近。" class="headerlink" title="例：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。"></a>例：给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; x==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//除去重复元素</span><br>            <span class="hljs-keyword">if</span>(x+nums[i+<span class="hljs-number">1</span>]+nums[i+<span class="hljs-number">2</span>]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <br>            <span class="hljs-keyword">if</span>(x+nums[n-<span class="hljs-number">2</span>]+nums[n-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;k)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x+nums[j]+nums[k];<br>                <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) k--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&lt;<span class="hljs-number">0</span>) j++;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    ans.add(List.of(x,nums[j],nums[k]));<br>                    <span class="hljs-keyword">for</span>(j++;j&lt;k &amp;&amp; nums[j] == nums[j-<span class="hljs-number">1</span>];j++);<br>                    <span class="hljs-keyword">for</span>(k--;k&gt;j &amp;&amp; nums[k]==nums[k+<span class="hljs-number">1</span>];k--);<span class="hljs-comment">//跳过重复数字</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="这里由于将数组排过序，可以利用排序后的顺序性质优化代码："><a href="#这里由于将数组排过序，可以利用排序后的顺序性质优化代码：" class="headerlink" title="这里由于将数组排过序，可以利用排序后的顺序性质优化代码："></a>这里由于将数组排过序，可以利用排序后的顺序性质优化代码：</h4><ol>
<li>利用双指针变量j,k 分别指向i+1和n-1,即数组的两端 </li>
<li>当j下标元素加k下标元素大于0时，证明k下标元素和前面任意元素相加都大于0，故要让k自减</li>
<li>当和小于0时，证明j下标元素和后面任意元素相加都小于0，故要让j自增，找更大的元素</li>
</ol>
</li>
<li><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><ol>
<li><pre><code class="java">if(x+nums[i+1]+nums[i+2]&gt;0) break;
//这里当i下标元素加上离该元素最近的两个元素时和大于0，证明i下标后面的元素相加都会大于0，可以直接退出循环
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>2. ```java<br>   if(x+nums[n-2]+nums[n-1]&lt;0) continue;<br>   //当i下标元素与数组最大的两个元素相加时小于0，证明i下标元素与后面元素相加都小于0，故可以跳过此次循环<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="java">for(j++;j&lt;k &amp;&amp; nums[j] == nums[j-1];j++);
for(k--;k&gt;j &amp;&amp; nums[k]==nums[k+1];k--);

//这里用于跳过数组中重复的数字

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  <br>- ### 同类型题解：四数之和<br><br>  给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：<br><br>  - `0 &lt;= a, b, c, d &lt; n`<br>  - `a`、`b`、`c` 和 `d` **互不相同**<br>  - `nums[a] + nums[b] + nums[c] + nums[d] == target`<br><br>  ```java<br>  class Solution &#123;<br>      public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;<br>          Arrays.sort(nums);<br>          int l = nums.length;<br>          List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();<br>          for(int i = 0;i&lt;l-3;i++)&#123;//枚举第一个数<br>              long x = nums[i];<br>              if(i&gt;0 &amp;&amp; x == nums[i-1]) continue;<br>              if((x+nums[i+1]+nums[i+2]+nums[i+3])&gt;target) break;<br>              if((x+nums[l-1]+nums[l-2]+nums[l-3])&lt;target) continue;<br>              for(int b = i+1;b&lt;l-2;b++)&#123; //这里与外层代码同理，枚举下一个元素<br>                  long y = nums[b];<br>                  if(b&gt;i+1 &amp;&amp; y == nums[b-1]) continue;<br>                  if((x+y+nums[b+1]+nums[b+2])&gt;target) break;<br>                  if((x+y+nums[l-1]+nums[l-2])&lt;target) continue;<br>                  int c = b+1;<br>                  int d = l-1;<br>                  while(c&lt;d)&#123;//枚举第三第四个数<br>                      long s = x + y + nums[c] + nums[d];<br>                      if(s&lt;target) c++;<br>                      else if(s&gt;target) d--;<br>                      else&#123;<br>                          ans.add(List.of((int)x,(int)y,nums[c],nums[d]));<br>                          for(c++;c&lt;d &amp;&amp; nums[c] == nums[c-1];c++);<br>                          for(d--;d&gt;c &amp;&amp; nums[d] == nums[d+1];d--);<br>                      &#125;<br>                  &#125;<br>              &#125;<br>          &#125;<br>          return ans;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="由此可见，双指针法可以简化两个数的和，无法简化两个数以上的和，因此需要多循环枚举来遍历所有数字"><a href="#由此可见，双指针法可以简化两个数的和，无法简化两个数以上的和，因此需要多循环枚举来遍历所有数字" class="headerlink" title="由此可见，双指针法可以简化两个数的和，无法简化两个数以上的和，因此需要多循环枚举来遍历所有数字"></a>由此可见，双指针法可以简化两个数的和，无法简化两个数以上的和，因此需要多循环枚举来遍历所有数字</h4></li>
</ul>
</li>
<li><h2 id="滑动窗口："><a href="#滑动窗口：" class="headerlink" title="滑动窗口："></a>滑动窗口：</h2><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<ul>
<li><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//子数组元素和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//子数组左端点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;right&lt;n;right++)&#123;<br>            sum+=nums[right];<br>            <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;<br>                ans = Math.min(ans,right-left+<span class="hljs-number">1</span>);<br>                sum-=nums[left++];<span class="hljs-comment">//左端点右移</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans&lt;=n ? ans : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找:"></a>二分查找:</h2><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<h3 id="这里的所有查找都是找到nums数组中-大于等于target-的第一个下标位置"><a href="#这里的所有查找都是找到nums数组中-大于等于target-的第一个下标位置" class="headerlink" title="这里的所有查找都是找到nums数组中&#x3D;&#x3D;大于等于target&#x3D;&#x3D;的第一个下标位置"></a>这里的所有查找都是找到nums数组中&#x3D;&#x3D;大于等于target&#x3D;&#x3D;的第一个下标位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">   <br><span class="hljs-comment">// 闭区间写法,即目标下标在闭区间内</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 闭区间 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right+1] &gt;= target</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-comment">//这里需要保证范围始终包含目标值，即区间一定得是闭区间的</span><br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br>   <br><span class="hljs-comment">// 左闭右开区间写法，即目标下标在左闭右开的区间内</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length; <span class="hljs-comment">// 左闭右开区间 [left, right)</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right] &gt;= target</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [mid+1, right)</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid; <span class="hljs-comment">// 范围缩小到 [left, mid)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 返回 left 还是 right 都行，因为循环结束后 left == right</span><br>&#125;<br>   <br><span class="hljs-comment">// 开区间写法,即目标区间在开区间内</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = nums.length; <span class="hljs-comment">// 开区间 (left, right)</span><br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left] &lt; target</span><br>        <span class="hljs-comment">// nums[right] &gt;= target</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid; <span class="hljs-comment">// 范围缩小到 (mid, right)</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid; <span class="hljs-comment">// 范围缩小到 (left, mid)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br>   <br></code></pre></td></tr></table></figure>

<h3 id="其他查找条件："><a href="#其他查找条件：" class="headerlink" title="其他查找条件："></a>其他查找条件：</h3><ul>
<li>找到大于target的第一个下标位置：即找到第一个大于等于target+1的位置</li>
<li>找到小于target的第一个下标位置：即找到大于等于target的上一个位置</li>
<li>找到小于等于target的第一个下标位置：即找到大于target的上一个位置</li>
</ul>
</li>
<li><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)&#123;<br>            p=p.next;<br>            len++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(len&lt;k)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head); <span class="hljs-comment">//作为反转链表的前一个节点，辅助反转</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span>head;<br>        <br>        <span class="hljs-keyword">for</span>(;len&gt;=k;len-=k)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>                cur.next = pre;<br>                pre = cur;<br>                cur = nxt;<br>            &#125;<br><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> p0.next;<span class="hljs-comment">//保存下一个要反转的节点的前一个结点</span><br>            p0.next.next = cur;<br>            p0.next = pre;<br>            p0  =  nxt;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用dummyNode-p0指针，令链表反转"><a href="#使用dummyNode-p0指针，令链表反转" class="headerlink" title="使用dummyNode,p0指针，令链表反转"></a>使用dummyNode,p0指针，令链表反转</h3><p class='item-img' data-src='E:\桌面\重要文件\image-20241110155709213.png'><img src="E:\桌面\重要文件\image-20241110155709213.png" alt="image-20241110155709213"></p>
</li>
<li><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="用于解决链表相关问题-例：在一个大小为-n-且-n-为-偶数-的链表中，对于-0"><a href="#用于解决链表相关问题-例：在一个大小为-n-且-n-为-偶数-的链表中，对于-0" class="headerlink" title="用于解决链表相关问题,例：在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;= i &lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。"></a>用于解决链表相关问题,例：在一个大小为 <code>n</code> 且 <code>n</code> 为 <strong>偶数</strong> 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <strong>0</strong> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</h3><ul>
<li>比方说，<code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</li>
</ul>
<p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。</p>
<p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pairSum</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//先找到中间结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMid(head);<br>        <span class="hljs-comment">//将另一半链表反转</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rl</span> <span class="hljs-operator">=</span> reverseList(mid);<br>        <span class="hljs-comment">//同时遍历两个链表，求出两个链表节点之和最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span> &amp;&amp; rl!=<span class="hljs-literal">null</span>)&#123;<br>            max = Math.max(head.val+rl.val,max);<br>            head = head.next;<br>            rl = rl.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-comment">//利用快慢指针找到链表中间节点</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">findMid</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head,fast = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-comment">//利用临时变量存储下一个节点信息来反转链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head,pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><h2 id="删除链表重复节点"><a href="#删除链表重复节点" class="headerlink" title="删除链表重复节点"></a>删除链表重复节点</h2><h2 id="只要-涉及删除头结点-的操作，大多需要初始化一个dummyNode协助操作"><a href="#只要-涉及删除头结点-的操作，大多需要初始化一个dummyNode协助操作" class="headerlink" title="只要&#x3D;&#x3D;涉及删除头结点&#x3D;&#x3D;的操作，大多需要初始化一个dummyNode协助操作"></a>只要&#x3D;&#x3D;涉及删除头结点&#x3D;&#x3D;的操作，大多需要初始化一个dummyNode协助操作</h2><p>有一个单链表的 <code>head</code>，我们想删除它其中的一个节点 <code>node</code>。</p>
<p>给你一个需要删除的节点 <code>node</code> 。你将 <strong>无法访问</strong> 第一个节点 <code>head</code>。</p>
<p>链表的所有值都是 <strong>唯一的</strong>，并且保证给定的节点 <code>node</code> 不是链表中的最后一个节点。</p>
<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>
<ul>
<li>给定节点的值不应该存在于链表中。</li>
<li>链表中的节点数应该减少 1。</li>
<li><code>node</code> 前面的所有值顺序相同。</li>
<li><code>node</code> 后面的所有值顺序相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.val = node.next.val;<br>        node.next = node.next.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="这里只需要将该节点的值修改为下一节点的值，并让该节点的next指针指向下下个节点即可。"><a href="#这里只需要将该节点的值修改为下一节点的值，并让该节点的next指针指向下下个节点即可。" class="headerlink" title="这里只需要将该节点的值修改为下一节点的值，并让该节点的next指针指向下下个节点即可。"></a>这里只需要将该节点的值修改为下一节点的值，并让该节点的next指针指向下下个节点即可。</h3><p>例2：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<span class="hljs-comment">//可能会删除头结点，故新建dummy节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>)&#123;<br>            right = right.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right.next!=<span class="hljs-literal">null</span>)&#123;<br>            left = left.next;<br>            right = right.next;<br>        &#125;<br>        left.next = left.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="例3：删除排序链表中的重复节点"><a href="#例3：删除排序链表中的重复节点" class="headerlink" title="例3：删除排序链表中的重复节点"></a>例3：删除排序链表中的重复节点</h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val==cur.val)&#123;<br>                cur.next = cur.next.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="例4：删除排序链表的所有重复节点"><a href="#例4：删除排序链表的所有重复节点" class="headerlink" title="例4：删除排序链表的所有重复节点"></a>例4：删除排序链表的所有重复节点</h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<span class="hljs-comment">//防止删除头结点情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-literal">null</span> &amp;&amp; cur.next.next!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//确保cur后面两个节点存在</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> cur.next.val;<br>            <span class="hljs-keyword">if</span>(val==cur.next.next.val)&#123;<span class="hljs-comment">//后两个节点值相同</span><br>                <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-literal">null</span>&amp;&amp;cur.next.val==val)&#123;<span class="hljs-comment">//循环，删除所有与该值相等的节点</span><br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = cur.next;<span class="hljs-comment">//值不相同，则将cur向后移动</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-start"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/11/10/redis/">← Next Redis进阶+基础</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">XB</a></h1><div id="description"><p>记录生活,记录代码,记录思考,记录知识</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">算法合集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%A4%9A%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">相向双指针解多数之和：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E4%B8%BA-n-%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84-nums-%E5%92%8C-%E4%B8%80%E4%B8%AA%E7%9B%AE%E6%A0%87%E5%80%BC-target%E3%80%82%E8%AF%B7%E4%BD%A0%E4%BB%8E-nums-%E4%B8%AD%E9%80%89%E5%87%BA%E4%B8%89%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E4%BD%BF%E5%AE%83%E4%BB%AC%E7%9A%84%E5%92%8C%E4%B8%8E-target-%E6%9C%80%E6%8E%A5%E8%BF%91%E3%80%82"><span class="toc-number">1.1.2.</span> <span class="toc-text">例：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E7%94%B1%E4%BA%8E%E5%B0%86%E6%95%B0%E7%BB%84%E6%8E%92%E8%BF%87%E5%BA%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%E8%B4%A8%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">这里由于将数组排过序，可以利用排序后的顺序性质优化代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">优化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E6%AD%A4%E5%8F%AF%E8%A7%81%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8C%96%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C%EF%BC%8C%E6%97%A0%E6%B3%95%E7%AE%80%E5%8C%96%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%92%8C%EF%BC%8C%E5%9B%A0%E6%AD%A4%E9%9C%80%E8%A6%81%E5%A4%9A%E5%BE%AA%E7%8E%AF%E6%9E%9A%E4%B8%BE%E6%9D%A5%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">由此可见，双指针法可以简化两个数的和，无法简化两个数以上的和，因此需要多循环枚举来遍历所有数字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">滑动窗口：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">代码实现：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.</span> <span class="toc-text">二分查找:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E7%9A%84%E6%89%80%E6%9C%89%E6%9F%A5%E6%89%BE%E9%83%BD%E6%98%AF%E6%89%BE%E5%88%B0nums%E6%95%B0%E7%BB%84%E4%B8%AD-%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Etarget-%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8B%E6%A0%87%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">这里的所有查找都是找到nums数组中&#x3D;&#x3D;大于等于target&#x3D;&#x3D;的第一个下标位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9F%A5%E6%89%BE%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">其他查找条件：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8dummyNode-p0%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%A4%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.4.1.</span> <span class="toc-text">使用dummyNode,p0指针，令链表反转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">1.5.</span> <span class="toc-text">快慢指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-%E4%BE%8B%EF%BC%9A%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%B0%8F%E4%B8%BA-n-%E4%B8%94-n-%E4%B8%BA-%E5%81%B6%E6%95%B0-%E7%9A%84%E9%93%BE%E8%A1%A8%E4%B8%AD%EF%BC%8C%E5%AF%B9%E4%BA%8E-0"><span class="toc-number">1.5.1.</span> <span class="toc-text">用于解决链表相关问题,例：在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;&#x3D; i &lt;&#x3D; (n &#x2F; 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">删除链表重复节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%A6%81-%E6%B6%89%E5%8F%8A%E5%88%A0%E9%99%A4%E5%A4%B4%E7%BB%93%E7%82%B9-%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A4%A7%E5%A4%9A%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAdummyNode%E5%8D%8F%E5%8A%A9%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.</span> <span class="toc-text">只要&#x3D;&#x3D;涉及删除头结点&#x3D;&#x3D;的操作，大多需要初始化一个dummyNode协助操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E5%B0%86%E8%AF%A5%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%BF%AE%E6%94%B9%E4%B8%BA%E4%B8%8B%E4%B8%80%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%EF%BC%8C%E5%B9%B6%E8%AE%A9%E8%AF%A5%E8%8A%82%E7%82%B9%E7%9A%84next%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E4%B8%8B%E4%B8%8B%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8D%B3%E5%8F%AF%E3%80%82"><span class="toc-number">1.7.1.</span> <span class="toc-text">这里只需要将该节点的值修改为下一节点的值，并让该节点的next指针指向下下个节点即可。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.2.</span> <span class="toc-text">例3：删除排序链表中的重复节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.3.</span> <span class="toc-text">例4：删除排序链表的所有重复节点</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>