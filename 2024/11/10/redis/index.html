<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Redis进阶+基础 | 徐博的博客</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Redis进阶+基础</h1></div><hr><div id="post-content"><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><ol>
<li><h2 id="redis缓存更新策略"><a href="#redis缓存更新策略" class="headerlink" title="redis缓存更新策略:"></a>redis缓存更新策略:</h2><ul>
<li><h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略:"></a>主动更新策略:</h3><h4 id="在更新数据的业务中同时更新缓存中数据"><a href="#在更新数据的业务中同时更新缓存中数据" class="headerlink" title="在更新数据的业务中同时更新缓存中数据"></a><strong>在更新数据的业务中同时更新缓存中数据</strong></h4><ol>
<li><p><strong>Cache Aside Pattern</strong>（主要用这个策略）: </p>
<p>由缓存的调用者，在更新数据库的<strong>同时更新缓存</strong></p>
<ul>
<li>更新缓存策略选删除缓存方案，在<strong>更新数据库同时让原来缓存失效</strong></li>
<li>解决线程安全问题:<ul>
<li><strong>先修改数据库，再删除缓存</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Read&#x2F;Write Through Pattern:</p>
<p>缓存与数据库整合为一个服务，由<strong>服务来维护一致性</strong>。</p>
</li>
<li><p>Write Behind Caching Pattern:</p>
<p>调用者只操作缓存，由其他<strong>线程异步将缓存数据持久化到数据库</strong>，保持最终一致</p>
</li>
</ol>
</li>
<li><h3 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰:"></a>内存淘汰:</h3><h4 id="利用redis的内存淘汰机制，当内存不足时自动淘汰一部分数据"><a href="#利用redis的内存淘汰机制，当内存不足时自动淘汰一部分数据" class="headerlink" title="利用redis的内存淘汰机制，当内存不足时自动淘汰一部分数据"></a>利用redis的内存淘汰机制，当内存不足时自动淘汰一部分数据</h4></li>
<li><h3 id="超时剔除："><a href="#超时剔除：" class="headerlink" title="超时剔除："></a>超时剔除：</h3><h4 id="给缓存数据添加TTL时间，到期自动删除缓存数据，下次查询更新缓存"><a href="#给缓存数据添加TTL时间，到期自动删除缓存数据，下次查询更新缓存" class="headerlink" title="给缓存数据添加TTL时间，到期自动删除缓存数据，下次查询更新缓存"></a>给缓存数据添加TTL时间，到期自动删除缓存数据，下次查询更新缓存</h4></li>
</ul>
</li>
<li><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="☞客户端请求的数据在缓存和数据库中都不存在，缓存永远不生效"><a href="#☞客户端请求的数据在缓存和数据库中都不存在，缓存永远不生效" class="headerlink" title="☞客户端请求的数据在缓存和数据库中都不存在，缓存永远不生效"></a>☞客户端请求的数据在缓存和数据库中都不存在，缓存永远不生效</h3><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><ul>
<li><h4 id="缓存空对象：将null缓存，设置TTL过期时间"><a href="#缓存空对象：将null缓存，设置TTL过期时间" class="headerlink" title="缓存空对象：将null缓存，设置TTL过期时间"></a>缓存空对象：将<strong>null</strong>缓存，设置TTL<strong>过期时间</strong></h4></li>
<li><h4 id="布隆过滤：设置过滤器，前置查询数据是否存在"><a href="#布隆过滤：设置过滤器，前置查询数据是否存在" class="headerlink" title="布隆过滤：设置过滤器，前置查询数据是否存在"></a>布隆过滤：设置过滤器，<strong>前置查询数据是否存在</strong></h4></li>
</ul>
</li>
<li><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="☞在同一时刻大量的缓存key同时失效或redis服务宕机，导致大量请求到达数据库"><a href="#☞在同一时刻大量的缓存key同时失效或redis服务宕机，导致大量请求到达数据库" class="headerlink" title="☞在同一时刻大量的缓存key同时失效或redis服务宕机，导致大量请求到达数据库"></a>☞在同一时刻大量的缓存key同时失效或redis服务宕机，导致大量请求到达数据库</h3><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案:"></a>解决方案:</h3><ol>
<li><h4 id="给不同key加随机的TTL-随机值"><a href="#给不同key加随机的TTL-随机值" class="headerlink" title="给不同key加随机的TTL&#x3D;&#x3D;随机值&#x3D;&#x3D;"></a>给不同key加随机的TTL&#x3D;&#x3D;随机值&#x3D;&#x3D;</h4></li>
<li><h4 id="利用redis集群提供服务可用性"><a href="#利用redis集群提供服务可用性" class="headerlink" title="利用redis集群提供服务可用性"></a>利用redis集群提供服务可用性</h4></li>
<li><h4 id="给缓存业务添加降级限流策略"><a href="#给缓存业务添加降级限流策略" class="headerlink" title="给缓存业务添加降级限流策略"></a>给缓存业务添加降级限流策略</h4></li>
<li><h4 id="给业务添加多级缓存"><a href="#给业务添加多级缓存" class="headerlink" title="给业务添加多级缓存"></a>给业务添加多级缓存</h4></li>
</ol>
</li>
<li><h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><h3 id="☞一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数请求会给数据库带来压力"><a href="#☞一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数请求会给数据库带来压力" class="headerlink" title="☞一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数请求会给数据库带来压力"></a>☞一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数请求会给数据库带来压力</h3><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案:"></a>解决方案:</h3><ul>
<li><h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期:"></a>逻辑过期:</h4><h5 id="在value中设置过期时间，当有一线程查询到过期数据时，会将更新数据操作交给另一线程，并且获取互斥锁，该锁只会在更新完数据后才释放，若在更新过程中有其他线程访问，获取不到互斥锁，即有线程在进行更新操作，则该线程会直接获取过期的旧数据。"><a href="#在value中设置过期时间，当有一线程查询到过期数据时，会将更新数据操作交给另一线程，并且获取互斥锁，该锁只会在更新完数据后才释放，若在更新过程中有其他线程访问，获取不到互斥锁，即有线程在进行更新操作，则该线程会直接获取过期的旧数据。" class="headerlink" title="在value中设置过期时间，当有一线程查询到过期数据时，会将更新数据操作交给另一线程，并且获取互斥锁，该锁只会在更新完数据后才释放，若在更新过程中有其他线程访问，获取不到互斥锁，即有线程在进行更新操作，则该线程会直接获取过期的旧数据。"></a>在value中设置过期时间，当有一线程查询到过期数据时，会将更新数据操作交给另一线程，并且获取互斥锁，该锁只会在更新完数据后才释放，若在更新过程中有其他线程访问，获取不到互斥锁，即有线程在进行更新操作，则该线程会直接获取过期的旧数据。</h5><p><strong>互斥锁实现方法</strong>：利用redis创建不可修改变量来模拟锁，这时其他线程尝试修改该变量时会返回false，即无法获取锁。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><h5 id="不保证一致性，会有额外的内存消耗，实现较为复杂。"><a href="#不保证一致性，会有额外的内存消耗，实现较为复杂。" class="headerlink" title="不保证一致性，会有额外的内存消耗，实现较为复杂。"></a>不保证一致性，会有额外的内存消耗，实现较为复杂。</h5></li>
<li><h4 id="互斥锁解决"><a href="#互斥锁解决" class="headerlink" title="互斥锁解决:"></a>互斥锁解决:</h4></li>
<li><p>![屏幕截图 2024-09-23 101811](E:\桌面\重要文件\屏幕截图 2024-09-23 101811-1727169685634-1.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁的方法，即在redis中创建一个不能被更改的值，当存在该key时，会返回false</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> 		     stringRedisTemplate.opsForValue().setIfAbsent(key,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>&#125;<br><br><span class="hljs-comment">//释放锁的方法,即删除该锁变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">(String key)</span>&#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="逻辑过期方式解决："><a href="#逻辑过期方式解决：" class="headerlink" title="逻辑过期方式解决："></a>逻辑过期方式解决：</h4><p>![屏幕截图 2024-09-23 103856](E:\桌面\重要文件\屏幕截图 2024-09-23 103856-1727169696221-3.png)</p>
<h5 id="创建一个包含expireTime过期时间属性的对象，例如向user对象加入expireTime的属性"><a href="#创建一个包含expireTime过期时间属性的对象，例如向user对象加入expireTime的属性" class="headerlink" title="创建一个包含expireTime过期时间属性的对象，例如向user对象加入expireTime的属性:"></a>创建一个包含expireTime过期时间属性的对象，例如向user对象加入expireTime的属性:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先创建一个包含过期时间属性的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span>&#123;<br>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br>    <span class="hljs-keyword">private</span> Object data;<span class="hljs-comment">//这里的data存放需要封装的对象</span><br>&#125;<br><br><br><span class="hljs-comment">//将包含过期时间属性的对象存入redis中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveShop</span><span class="hljs-params">(Long id,Long expireTime)</span>&#123;<br>    <span class="hljs-comment">//1.先查询信息</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getByid(id);<br>    <span class="hljs-comment">//2.封装逻辑过期时间</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>    redisData.setData(shop);<br>    redisData.setExpireTime(LocalDateTime.now.plusSeconds(expireTime));<br>    <span class="hljs-comment">//3.写入redis</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;local:shop:&quot;</span>+id,JSON.toJsonString(redisData));<br>&#125;<br><br><span class="hljs-comment">//创建线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//获取缓存数据，并判断是否过期</span><br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(Long id)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;local:shop:&quot;</span>+id;<br>    <span class="hljs-comment">//从redis查询缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">//判断是否存在</span><br>    <span class="hljs-keyword">if</span>(shopJson==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//不存在，返回null</span><br>    &#125;<br>    <span class="hljs-comment">//缓存查找命中，先把json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSON.parseObject(shopJson,RedisData.class);<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (JSONObject) redisData.getData();<span class="hljs-comment">//这里拿到的是jsonObject对象</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSON.praseObject(data,Shop.class);<br>    <span class="hljs-comment">//判断是否过期</span><br>    <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;<br>        <span class="hljs-comment">//未过期，返回店铺信息</span><br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">//已过期，重建缓存</span><br>    <span class="hljs-comment">//缓存重建</span><br>    <span class="hljs-comment">//获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span>+id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">//判断获取锁是否成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-comment">//成功，则开启独立线程，实现缓存重建</span><br>        <span class="hljs-comment">//这里需要再次检测redis缓存是否过期，如果存在则无需重建缓存</span><br>        <span class="hljs-comment">//从redis查询缓存</span><br>    	shopJson = stringRedisTemplate.opsForValue().get(key);<br>    	<span class="hljs-comment">//判断是否存在</span><br>    	<span class="hljs-keyword">if</span>(shopJson==<span class="hljs-literal">null</span>)&#123;<br>        	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//不存在，返回null</span><br>    	&#125;<br>        redisData = JSON.parseObject(shopJson,RedisData.class);<br>    	data = (JSONObject) redisData.getData();<span class="hljs-comment">//这里拿到的是jsonObject对象</span><br>    	shop = JSON.praseObject(data,Shop.class);<br>    	<span class="hljs-comment">//判断是否过期</span><br>    	<span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;<br>        	<span class="hljs-comment">//未过期，返回店铺信息</span><br>        	<span class="hljs-keyword">return</span> shop;<br>    	&#125;<br>        <span class="hljs-comment">//过期，则开启独立线程重建缓存</span><br>        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;<br>            <span class="hljs-comment">//调用缓存重建方法</span><br>            <span class="hljs-built_in">this</span>.saveShop(id,<span class="hljs-number">20L</span>);<span class="hljs-comment">//设置20s的过期时间</span><br>            <span class="hljs-comment">//释放锁</span><br>            unlock(lockKey);<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">//失败，返回过期的商品信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h2 id="利用redis实现全局唯一ID"><a href="#利用redis实现全局唯一ID" class="headerlink" title="利用redis实现全局唯一ID"></a>利用redis实现全局唯一ID</h2><ul>
<li><h3 id="为实现安全性，需要在id中拼接一些其他信息"><a href="#为实现安全性，需要在id中拼接一些其他信息" class="headerlink" title="为实现安全性，需要在id中拼接一些其他信息:"></a>为实现安全性，需要在id中拼接一些其他信息:</h3><p class='item-img' data-src='E:\桌面\重要文件\image-20240923201519791.png'><img src="E:\桌面\重要文件\image-20240923201519791.png" alt="image-20240923201519791"></p>
</li>
<li><pre><code class="java">public class RedisIdWorker&#123;
    private StringRedisTemplate redisTemplate;

    public RedisIdWorker(StringRedisTemplate redisTemplate)&#123;
        this.redisTemplate = redisTemplate;
    &#125;

    /**
     * 开始时间戳，从24/1/1开始
     */
    private static final long BEGIN_LOCALTIME = 1704067200L;

    /**
     * 序列号位数
     */
    private static final int COUNT_BITS = 32;

    public long nextId(String keyPrefix)&#123;
        //生成id

        //1.生成时间戳，计算当前时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timeStamp = nowSecond-BEGIN_LOCALTIME;

        //2.生成序列号
        //2.1.获取当前日期，精确到天
        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));
        //2.2.自增长
        Long count = redisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);
        //3.拼接并返回
        return timeStamp &lt;&lt; COUNT_BITS | count;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>6. ## 乐观锁解决高并发线程问题<br><br>   - ### 在更新时判断是否有其他线程在修改数据库<br><br>   ![image-20240923212224180](E:\桌面\重要文件\image-20240923212224180.png)<br><br>   ### ==改进：将约束条件换为stock&gt;0==<br><br>7. ## spring中，某个类调用自身的方法时，若该方法加了事务注解，该事务会失效，需要利用该对象的代理对象才能使用事务。<br><br>   ```java<br>   public class Test()&#123;<br>       @Transactional<br>       public Result createOrder()&#123;<br>           ...<br>       &#125;<br>       <br>       public void test()&#123;<br>           ...<br>           //获取代理对象<br>          	Test proxy = (Test)AopContext.currentProxy();<br>           //调用代理对象方法<br>           proxy.createOrder();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><h2 id="基于redis实现分布式锁"><a href="#基于redis实现分布式锁" class="headerlink" title="基于redis实现分布式锁"></a>基于redis实现分布式锁</h2><ul>
<li><h4 id="两个基本方法"><a href="#两个基本方法" class="headerlink" title="两个基本方法:"></a>两个基本方法:</h4><ol>
<li><h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁:"></a>获取锁:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#添加锁，利用setnx互斥特性<br>SETNX lock thread1<br>#添加过期时间,避免服务宕机引起的死锁<br>EXPIRE lock 10<br></code></pre></td></tr></table></figure>

<p>互斥，确保只能有一个线程获取锁</p>
</li>
<li><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁:"></a>释放锁:</h5><p>删除锁即可，需要设置超时释放时间</p>
</li>
</ol>
</li>
<li><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> String lockName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate)</span>&#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">//获取线程标识</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">//获取锁</span><br><br>        <span class="hljs-comment">//这里的threadId为锁标识，用于保证线程始终处理的锁都是一致的</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + lockName, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(result);<span class="hljs-comment">//这样若result为空，也会返回false</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//释放锁</span><br>        redisTemplate.delete(KEY_PREFIX + lockName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="改进redis分布式锁"><a href="#改进redis分布式锁" class="headerlink" title="改进redis分布式锁:"></a>改进redis分布式锁:</h4><ul>
<li><h5 id="获取锁时存入线程标识-用UUID表示"><a href="#获取锁时存入线程标识-用UUID表示" class="headerlink" title="获取锁时存入线程标识(用UUID表示)"></a>获取锁时存入线程标识(用UUID表示)</h5></li>
<li><h5 id="释放锁时先获取锁中的线程标识，判断是否与当前线程标识一致"><a href="#释放锁时先获取锁中的线程标识，判断是否与当前线程标识一致" class="headerlink" title="释放锁时先获取锁中的线程标识，判断是否与当前线程标识一致"></a>释放锁时先获取锁中的线程标识，判断是否与当前线程标识一致</h5><ul>
<li><h5 id="一致则释放锁"><a href="#一致则释放锁" class="headerlink" title="一致则释放锁"></a>一致则释放锁</h5></li>
<li><h5 id="不一致则不释放"><a href="#不一致则不释放" class="headerlink" title="不一致则不释放"></a>不一致则不释放</h5></li>
<li><h5 id="防止由于业务阻塞而误删锁"><a href="#防止由于业务阻塞而误删锁" class="headerlink" title="防止由于业务阻塞而误删锁"></a>防止由于业务阻塞而误删锁</h5></li>
<li><p>代码:</p>
</li>
<li><pre><code class="java">public class RedisLock implements ILock&#123;
    private final StringRedisTemplate redisTemplate;
    private String lockName;
    private static final String KEY_PREFIX = &quot;lock:&quot;;
    //获取UUID
    private static final String ID_PREFIX = UUID.randomUUID().toString(true);

    //加载lua脚本
    private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;
    static &#123;
        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;));
        UNLOCK_SCRIPT.setResultType(Long.class);
    &#125;


    public RedisLock(StringRedisTemplate redisTemplate)&#123;
        this.redisTemplate = redisTemplate;
    &#125;

    @Override
    public boolean tryLock(long timeoutSec) &#123;
        //获取线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();

        //获取锁
        //这里的threadId为锁标识，用于保证线程始终处理的锁都是一致的
        Boolean result = redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + lockName, threadId, timeoutSec, TimeUnit.SECONDS);

        return Boolean.TRUE.equals(result);//这样若result为空，也会返回false
    &#125;

    @Override
    public void unlock() &#123;
        //使用lua脚本,确保原子性，解决锁的误删
        redisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX+lockName),
                ID_PREFIX + Thread.currentThread().getId()
                );
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>- ### redis锁的进一步改进:<br><br>  - #### 存在问题:<br><br>    ![image-20240924191053966](E:\桌面\重要文件\image-20240924191053966.png)<br><br>- ### redisson可重入锁原理<br><br>  ![image-20240925160643891](E:\桌面\重要文件\image-20240925160643891.png)<br><br>  ```lua<br>  --使用lua脚本编写获取可重入锁<br>  local key = KEYS[1]<br>  local threadId = ARGV[1]<br>  local releaseTime = ARGV[2]<br>  <br>  --判断是否存在<br>  if (redis.call(&#x27;exists&#x27;,key)==0) then<br>      --不存在，获取锁<br>      redis.call(&#x27;hset&#x27;,key,threadId,&#x27;1&#x27;);<br>      --设置有效期<br>      redis.call(&#x27;expire&#x27;,key,releaseTime);<br>      return 1;<br>  end;<br>  <br>  --锁已经存在，判断threadId是否是自己<br>  if(redis.call(&#x27;hexists&#x27;,key,threadId)==1) then<br>      --不存在，获取锁，重入次数加一<br>      redis.call(&#x27;hincrby&#x27;,key,threadId,&#x27;1&#x27;);<br>      --设置有效期<br>      redis.call(&#x27;expire&#x27;,key,releaseTime);<br>      return 1;<br>  end;<br>  return 0;--表示获取的锁不是自己，获取锁失败<br>  <br>  <br>  --使用lua脚本释放可重入锁<br>  <br>  --判断当前锁释放还被自己持有<br>  if(redis.call(&#x27;HEXISTS&#x27;,key,threadId)==0) then<br>      return nil;<br>  end;<br>  --是自己的锁则重入次数减一<br>  local count = redis.call(&#x27;HINCRBY&#x27;,key, threadId, -1);<br>  --判断是否重入次数<br>  if(count&gt;0) then<br>      --大于零说明不能释放锁，重置有效期后返回<br>      redis.call(&#x27;expire&#x27;,key,releaseTime);<br>      return nil;<br>  else --等于0说明可以释放锁，直接删除<br>      redis.call(&#x27;del&#x27;,key);<br>      return nil;<br>  end;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="主从搭建："><a href="#主从搭建：" class="headerlink" title="主从搭建："></a>主从搭建：</h2><ul>
<li><h3 id="主从数据同步原理："><a href="#主从数据同步原理：" class="headerlink" title="主从数据同步原理："></a>主从数据同步原理：</h3><h4 id="数据同步有两种方式：全量同步与增量同步"><a href="#数据同步有两种方式：全量同步与增量同步" class="headerlink" title="数据同步有两种方式：全量同步与增量同步"></a>数据同步有两种方式：全量同步与增量同步</h4><h4 id="replicationID"><a href="#replicationID" class="headerlink" title="replicationID:"></a>replicationID:</h4><h4 id="每一个master节点都有自己唯一的id，简称replid。当slaver节点尝试同步master数据时，master会将自己的id发给slaver，当slaver尝试同步数据时，master会通过它的id与自己的id比较来判断是否为第一次同步数据"><a href="#每一个master节点都有自己唯一的id，简称replid。当slaver节点尝试同步master数据时，master会将自己的id发给slaver，当slaver尝试同步数据时，master会通过它的id与自己的id比较来判断是否为第一次同步数据" class="headerlink" title="每一个master节点都有自己唯一的id，简称replid。当slaver节点尝试同步master数据时，master会将自己的id发给slaver，当slaver尝试同步数据时，master会通过它的id与自己的id比较来判断是否为第一次同步数据"></a>每一个master节点都有自己唯一的id，简称replid。当slaver节点尝试同步master数据时，master会将自己的id发给slaver，当slaver尝试同步数据时，master会通过它的id与自己的id比较来判断是否为第一次同步数据</h4><h4 id="offset"><a href="#offset" class="headerlink" title="offset:"></a>offset:</h4><h4 id="repl-backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致"><a href="#repl-backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致" class="headerlink" title="repl_backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致"></a>repl_backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致</h4><p class='item-img' data-src='E:\桌面\重要文件\image-20241022213852584.png'><img src="E:\桌面\重要文件\image-20241022213852584.png" alt="image-20241022213852584"></p>
</li>
<li><h4 id="优化全量同步："><a href="#优化全量同步：" class="headerlink" title="优化全量同步："></a>优化全量同步：</h4><ul>
<li>在master中配置repl-diskless-sync yes 启用无磁盘复制</li>
<li>redis单节点内存不要过大</li>
<li>适当提高repl_baklog的大小，发项slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slaver数量，若数量过多，可采用主-从-从链式结构，减少master压力</li>
</ul>
</li>
<li><h3 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h3><h4 id="redis中的哨兵集群的作用："><a href="#redis中的哨兵集群的作用：" class="headerlink" title="redis中的哨兵集群的作用："></a>redis中的哨兵集群的作用：</h4><ol>
<li><h5 id="监控：监测master和slaver是否正常工作"><a href="#监控：监测master和slaver是否正常工作" class="headerlink" title="监控：监测master和slaver是否正常工作"></a>监控：监测master和slaver是否正常工作</h5></li>
<li><h5 id="自动故障切换：若master故障，哨兵会把一个slaver自动提升为master，原来的master故障恢复也会变为新master的slaver"><a href="#自动故障切换：若master故障，哨兵会把一个slaver自动提升为master，原来的master故障恢复也会变为新master的slaver" class="headerlink" title="自动故障切换：若master故障，哨兵会把一个slaver自动提升为master，原来的master故障恢复也会变为新master的slaver"></a>自动故障切换：若master故障，哨兵会把一个slaver自动提升为master，原来的master故障恢复也会变为新master的slaver</h5></li>
<li><h5 id="通知：当集群发生故障转移时，哨兵会将最新节点信息推送给redis客户端"><a href="#通知：当集群发生故障转移时，哨兵会将最新节点信息推送给redis客户端" class="headerlink" title="通知：当集群发生故障转移时，哨兵会将最新节点信息推送给redis客户端"></a>通知：当集群发生故障转移时，哨兵会将最新节点信息推送给redis客户端</h5></li>
</ol>
<h5 id="监控原理："><a href="#监控原理：" class="headerlink" title="监控原理："></a>监控原理：</h5><p>利用心跳检测机制，每1秒向集群每个实例发送ping命令</p>
<p class='item-img' data-src='E:\桌面\重要文件\image-20241024195501567.png'><img src="E:\桌面\重要文件\image-20241024195501567.png" alt="image-20241024195501567"></p>
<h4 id="选举新的master机制："><a href="#选举新的master机制：" class="headerlink" title="选举新的master机制："></a>选举新的master机制：</h4><p class='item-img' data-src='E:\桌面\重要文件\image-20241024195844636.png'><img src="E:\桌面\重要文件\image-20241024195844636.png" alt="image-20241024195844636"></p>
<h4 id="实现故障转移："><a href="#实现故障转移：" class="headerlink" title="实现故障转移："></a>实现故障转移：</h4><p class='item-img' data-src='E:\桌面\重要文件\image-20241024200125449.png'><img src="E:\桌面\重要文件\image-20241024200125449.png" alt="image-20241024200125449"></p>
</li>
<li><h3 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h3><ol>
<li><h4 id="用于解决的问题："><a href="#用于解决的问题：" class="headerlink" title="用于解决的问题："></a>用于解决的问题：</h4><h5 id="海量数据存储问题"><a href="#海量数据存储问题" class="headerlink" title="海量数据存储问题"></a>海量数据存储问题</h5><h5 id="高并发写的问题"><a href="#高并发写的问题" class="headerlink" title="高并发写的问题"></a>高并发写的问题</h5></li>
<li><h4 id="集群特征："><a href="#集群特征：" class="headerlink" title="集群特征："></a>集群特征：</h4><h5 id="集群中有多个master，用于保存不同数据"><a href="#集群中有多个master，用于保存不同数据" class="headerlink" title="集群中有多个master，用于保存不同数据"></a>集群中有多个master，用于保存不同数据</h5><h5 id="每个master都可以有多个slave节点"><a href="#每个master都可以有多个slave节点" class="headerlink" title="每个master都可以有多个slave节点"></a>每个master都可以有多个slave节点</h5><h5 id="master之间可以互相ping监测彼此健康状态"><a href="#master之间可以互相ping监测彼此健康状态" class="headerlink" title="master之间可以互相ping监测彼此健康状态"></a>master之间可以互相ping监测彼此健康状态</h5></li>
</ol>
</li>
<li><h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3 class='item-img' data-src='E:\桌面\重要文件\image-20241024202945870.png'><img src="E:\桌面\重要文件\image-20241024202945870.png" alt="image-20241024202945870"  />
</li>
<li><h3 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList:"></a>SkipList:</h3><h4 id="本质上是链表，但与传统链表有些差异："><a href="#本质上是链表，但与传统链表有些差异：" class="headerlink" title="本质上是链表，但与传统链表有些差异："></a>本质上是链表，但与传统链表有些差异：</h4><ul>
<li><h5 id="元素按照升序排序存储"><a href="#元素按照升序排序存储" class="headerlink" title="元素按照升序排序存储"></a>元素按照升序排序存储</h5></li>
<li><h5 id="节点可能包含多层指针，指针跨度不同"><a href="#节点可能包含多层指针，指针跨度不同" class="headerlink" title="节点可能包含多层指针，指针跨度不同"></a>节点可能包含多层指针，指针跨度不同</h5></li>
<li><h5 id="增删改效率与红黑树基本一致，实现更简单"><a href="#增删改效率与红黑树基本一致，实现更简单" class="headerlink" title="增删改效率与红黑树基本一致，实现更简单"></a>增删改效率与红黑树基本一致，实现更简单</h5></li>
</ul>
</li>
<li><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><h5 id="每组数据都包含score和member"><a href="#每组数据都包含score和member" class="headerlink" title="每组数据都包含score和member"></a>每组数据都包含score和member</h5></li>
<li><h5 id="member唯一"><a href="#member唯一" class="headerlink" title="member唯一"></a>member唯一</h5></li>
<li><h5 id="可依据score排序"><a href="#可依据score排序" class="headerlink" title="可依据score排序"></a>可依据score排序</h5></li>
</ul>
<h4 id="底层数据结构："><a href="#底层数据结构：" class="headerlink" title="底层数据结构："></a>底层数据结构：</h4><ul>
<li><h5 id="底层有一个哈希表用于-用member查询score-，还有一个skipset用于-使用score查询member"><a href="#底层有一个哈希表用于-用member查询score-，还有一个skipset用于-使用score查询member" class="headerlink" title="底层有一个哈希表用于&#x3D;&#x3D;用member查询score&#x3D;&#x3D;，还有一个skipset用于&#x3D;&#x3D;使用score查询member&#x3D;&#x3D;"></a>底层有一个哈希表用于&#x3D;&#x3D;用member查询score&#x3D;&#x3D;，还有一个skipset用于&#x3D;&#x3D;使用score查询member&#x3D;&#x3D;</h5></li>
<li><h5 id="由于需要用score来进行排序，因此底层有维护一个跳表"><a href="#由于需要用score来进行排序，因此底层有维护一个跳表" class="headerlink" title="由于需要用score来进行排序，因此底层有维护一个跳表"></a>由于需要用score来进行排序，因此底层有维护一个跳表</h5></li>
</ul>
</li>
<li><h3 id="过期KEY处理原理"><a href="#过期KEY处理原理" class="headerlink" title="过期KEY处理原理"></a>过期KEY处理原理</h3><h5 id="redis所有数据存放在redisDb结构体中，其中包含两个哈希表："><a href="#redis所有数据存放在redisDb结构体中，其中包含两个哈希表：" class="headerlink" title="redis所有数据存放在redisDb结构体中，其中包含两个哈希表："></a>redis所有数据存放在redisDb结构体中，其中包含两个哈希表：</h5><ul>
<li><h5 id="dict：保存redis中所有键值对"><a href="#dict：保存redis中所有键值对" class="headerlink" title="dict：保存redis中所有键值对"></a>dict：保存redis中所有键值对</h5></li>
<li><h5 id="expires：保存redis中所有设置了过期时间的key及其到期时间-写入时间-TTL"><a href="#expires：保存redis中所有设置了过期时间的key及其到期时间-写入时间-TTL" class="headerlink" title="expires：保存redis中所有设置了过期时间的key及其到期时间(&#x3D;&#x3D;写入时间+TTL&#x3D;&#x3D;)"></a>expires：保存redis中所有设置了过期时间的key及其到期时间(&#x3D;&#x3D;写入时间+TTL&#x3D;&#x3D;)</h5></li>
</ul>
<h5 id="过期key的延时删除策略："><a href="#过期key的延时删除策略：" class="headerlink" title="过期key的延时删除策略："></a>过期key的延时删除策略：</h5><ul>
<li><h5 id="惰性删除：每当需要对该key操作时，会判断该key的存活时间，已经过期了才执行删除"><a href="#惰性删除：每当需要对该key操作时，会判断该key的存活时间，已经过期了才执行删除" class="headerlink" title="惰性删除：每当需要对该key操作时，会判断该key的存活时间，已经过期了才执行删除"></a>惰性删除：每当需要对该key操作时，会判断该key的存活时间，已经过期了才执行删除</h5></li>
<li><h5 id="周期删除：通过定时任务，周期性的抽样部分有TTL的key，若过期则删除"><a href="#周期删除：通过定时任务，周期性的抽样部分有TTL的key，若过期则删除" class="headerlink" title="周期删除：通过定时任务，周期性的抽样部分有TTL的key，若过期则删除"></a>周期删除：通过定时任务，周期性的抽样部分有TTL的key，若过期则删除</h5></li>
</ul>
</li>
<li><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><h4 id="当redis内存使用达到设置阈值时，会主动挑选部分key删除以释放更多内存"><a href="#当redis内存使用达到设置阈值时，会主动挑选部分key删除以释放更多内存" class="headerlink" title="当redis内存使用达到设置阈值时，会主动挑选部分key删除以释放更多内存"></a>当redis内存使用达到设置阈值时，会主动挑选部分key删除以释放更多内存</h4><p class='item-img' data-src='E:\桌面\重要文件\image-20241024210912675.png'><img src="E:\桌面\重要文件\image-20241024210912675.png" alt="image-20241024210912675"></p>
<h4 id="推荐使用带-volatile-的过期机制，这样将淘汰限制在只对设置了TTL的key"><a href="#推荐使用带-volatile-的过期机制，这样将淘汰限制在只对设置了TTL的key" class="headerlink" title="推荐使用带&#x3D;&#x3D;volatile&#x3D;&#x3D;的过期机制，这样将淘汰限制在只对设置了TTL的key"></a>推荐使用带&#x3D;&#x3D;volatile&#x3D;&#x3D;的过期机制，这样将淘汰限制在只对设置了TTL的key</h4><h4 id="推荐使用带-LFU-的算法，这样会减少误淘汰重要数据"><a href="#推荐使用带-LFU-的算法，这样会减少误淘汰重要数据" class="headerlink" title="推荐使用带&#x3D;&#x3D;LFU&#x3D;&#x3D;的算法，这样会减少误淘汰重要数据"></a>推荐使用带&#x3D;&#x3D;LFU&#x3D;&#x3D;的算法，这样会减少误淘汰重要数据</h4><p class='item-img' data-src='E:\桌面\重要文件\image-20241024211923645.png'><img src="E:\桌面\重要文件\image-20241024211923645.png" alt="image-20241024211923645"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/11/12/RabbitMQ/">← 下一篇 Rabbit基础+进阶</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/11/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/">算法合集 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">XB</a></h1><div id="description"><p>记录生活,记录代码,记录思考,记录知识</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#redis"><span class="toc-number">1.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.</span> <span class="toc-text">redis缓存更新策略:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">主动更新策略:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">在更新数据的业务中同时更新缓存中数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">内存淘汰:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BD%93%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E8%87%AA%E5%8A%A8%E6%B7%98%E6%B1%B0%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">利用redis的内存淘汰机制，当内存不足时自动淘汰一部分数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E5%89%94%E9%99%A4%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">超时剔除：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0TTL%E6%97%B6%E9%97%B4%EF%BC%8C%E5%88%B0%E6%9C%9F%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8B%E6%AC%A1%E6%9F%A5%E8%AF%A2%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">给缓存数据添加TTL时间，到期自动删除缓存数据，下次查询更新缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.2.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%9E%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%83%BD%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E7%BC%93%E5%AD%98%E6%B0%B8%E8%BF%9C%E4%B8%8D%E7%94%9F%E6%95%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">☞客户端请求的数据在缓存和数据库中都不存在，缓存永远不生效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">解决方案:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%B0%86null%E7%BC%93%E5%AD%98%EF%BC%8C%E8%AE%BE%E7%BD%AETTL%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">缓存空对象：将null缓存，设置TTL过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%89%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">布隆过滤：设置过滤器，前置查询数据是否存在</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%9E%E5%9C%A8%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E5%A4%A7%E9%87%8F%E7%9A%84%E7%BC%93%E5%AD%98key%E5%90%8C%E6%97%B6%E5%A4%B1%E6%95%88%E6%88%96redis%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.3.1.</span> <span class="toc-text">☞在同一时刻大量的缓存key同时失效或redis服务宕机，导致大量请求到达数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">解决方案:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E4%B8%8D%E5%90%8Ckey%E5%8A%A0%E9%9A%8F%E6%9C%BA%E7%9A%84TTL-%E9%9A%8F%E6%9C%BA%E5%80%BC"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">给不同key加随机的TTL&#x3D;&#x3D;随机值&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8redis%E9%9B%86%E7%BE%A4%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">利用redis集群提供服务可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E7%BC%93%E5%AD%98%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E9%99%8D%E7%BA%A7%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">给缓存业务添加降级限流策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">给业务添加多级缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">缓存击穿：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%9E%E4%B8%80%E4%B8%AA%E8%A2%AB%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%B9%B6%E4%B8%94%E7%BC%93%E5%AD%98%E9%87%8D%E5%BB%BA%E4%B8%9A%E5%8A%A1%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84key%E7%AA%81%E7%84%B6%E5%A4%B1%E6%95%88%E4%BA%86%EF%BC%8C%E6%97%A0%E6%95%B0%E8%AF%B7%E6%B1%82%E4%BC%9A%E7%BB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%A6%E6%9D%A5%E5%8E%8B%E5%8A%9B"><span class="toc-number">1.4.1.</span> <span class="toc-text">☞一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数请求会给数据库带来压力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">解决方案:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">逻辑过期:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8value%E4%B8%AD%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%8C%E5%BD%93%E6%9C%89%E4%B8%80%E7%BA%BF%E7%A8%8B%E6%9F%A5%E8%AF%A2%E5%88%B0%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%B0%86%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%BA%A4%E7%BB%99%E5%8F%A6%E4%B8%80%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%8E%B7%E5%8F%96%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E8%AF%A5%E9%94%81%E5%8F%AA%E4%BC%9A%E5%9C%A8%E6%9B%B4%E6%96%B0%E5%AE%8C%E6%95%B0%E6%8D%AE%E5%90%8E%E6%89%8D%E9%87%8A%E6%94%BE%EF%BC%8C%E8%8B%A5%E5%9C%A8%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%89%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%EF%BC%8C%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E5%8D%B3%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%88%99%E8%AF%A5%E7%BA%BF%E7%A8%8B%E4%BC%9A%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%8F%96%E8%BF%87%E6%9C%9F%E7%9A%84%E6%97%A7%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">在value中设置过期时间，当有一线程查询到过期数据时，会将更新数据操作交给另一线程，并且获取互斥锁，该锁只会在更新完数据后才释放，若在更新过程中有其他线程访问，获取不到互斥锁，即有线程在进行更新操作，则该线程会直接获取过期的旧数据。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E4%BC%9A%E6%9C%89%E9%A2%9D%E5%A4%96%E7%9A%84%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BE%83%E4%B8%BA%E5%A4%8D%E6%9D%82%E3%80%82"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">不保证一致性，会有额外的内存消耗，实现较为复杂。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">互斥锁解决:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%EF%BC%9A"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">逻辑过期方式解决：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%ABexpireTime%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%90%91user%E5%AF%B9%E8%B1%A1%E5%8A%A0%E5%85%A5expireTime%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.2.4.1.</span> <span class="toc-text">创建一个包含expireTime过期时间属性的对象，例如向user对象加入expireTime的属性:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">1.5.</span> <span class="toc-text">利用redis实现全局唯一ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8id%E4%B8%AD%E6%8B%BC%E6%8E%A5%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">为实现安全性，需要在id中拼接一些其他信息:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eredis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">基于redis实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">两个基本方法:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">1.6.0.1.1.</span> <span class="toc-text">获取锁:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.6.0.1.2.</span> <span class="toc-text">释放锁:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">代码实现:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9Bredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">改进redis分布式锁:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%81%E6%97%B6%E5%AD%98%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86-%E7%94%A8UUID%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.6.0.3.1.</span> <span class="toc-text">获取锁时存入线程标识(用UUID表示)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81%E6%97%B6%E5%85%88%E8%8E%B7%E5%8F%96%E9%94%81%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%8E%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86%E4%B8%80%E8%87%B4"><span class="toc-number">1.6.0.3.2.</span> <span class="toc-text">释放锁时先获取锁中的线程标识，判断是否与当前线程标识一致</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E5%88%99%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.6.0.3.3.</span> <span class="toc-text">一致则释放锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E4%B8%80%E8%87%B4%E5%88%99%E4%B8%8D%E9%87%8A%E6%94%BE"><span class="toc-number">1.6.0.3.4.</span> <span class="toc-text">不一致则不释放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%94%B1%E4%BA%8E%E4%B8%9A%E5%8A%A1%E9%98%BB%E5%A1%9E%E8%80%8C%E8%AF%AF%E5%88%A0%E9%94%81"><span class="toc-number">1.6.0.3.5.</span> <span class="toc-text">防止由于业务阻塞而误删锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">主从搭建：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">主从数据同步原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">数据同步有两种方式：全量同步与增量同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationID"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">replicationID:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%B8%80%E4%B8%AAmaster%E8%8A%82%E7%82%B9%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E5%94%AF%E4%B8%80%E7%9A%84id%EF%BC%8C%E7%AE%80%E7%A7%B0replid%E3%80%82%E5%BD%93slaver%E8%8A%82%E7%82%B9%E5%B0%9D%E8%AF%95%E5%90%8C%E6%AD%A5master%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8Cmaster%E4%BC%9A%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84id%E5%8F%91%E7%BB%99slaver%EF%BC%8C%E5%BD%93slaver%E5%B0%9D%E8%AF%95%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8Cmaster%E4%BC%9A%E9%80%9A%E8%BF%87%E5%AE%83%E7%9A%84id%E4%B8%8E%E8%87%AA%E5%B7%B1%E7%9A%84id%E6%AF%94%E8%BE%83%E6%9D%A5%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">每一个master节点都有自己唯一的id，简称replid。当slaver节点尝试同步master数据时，master会将自己的id发给slaver，当slaver尝试同步数据时，master会通过它的id与自己的id比较来判断是否为第一次同步数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#offset"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">offset:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repl-backlog%E4%B8%AD%E5%86%99%E5%85%A5%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%86%99%E6%93%8D%E4%BD%9C%E8%B6%8A%E5%A4%9A%EF%BC%8Coffset%E5%80%BC%E8%B6%8A%E5%A4%A7%EF%BC%8C%E4%B8%BB%E4%BB%8E%E7%9A%84offset%E4%B8%80%E8%87%B4%E4%BB%A3%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">repl_backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%EF%BC%9A"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">优化全量同步：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">哨兵原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E4%B8%AD%E7%9A%84%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">redis中的哨兵集群的作用：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%EF%BC%9A%E7%9B%91%E6%B5%8Bmaster%E5%92%8Cslaver%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.7.2.1.1.</span> <span class="toc-text">监控：监测master和slaver是否正常工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%EF%BC%9A%E8%8B%A5master%E6%95%85%E9%9A%9C%EF%BC%8C%E5%93%A8%E5%85%B5%E4%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AAslaver%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E4%B8%BAmaster%EF%BC%8C%E5%8E%9F%E6%9D%A5%E7%9A%84master%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E4%B9%9F%E4%BC%9A%E5%8F%98%E4%B8%BA%E6%96%B0master%E7%9A%84slaver"><span class="toc-number">1.7.2.1.2.</span> <span class="toc-text">自动故障切换：若master故障，哨兵会把一个slaver自动提升为master，原来的master故障恢复也会变为新master的slaver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%EF%BC%9A%E5%BD%93%E9%9B%86%E7%BE%A4%E5%8F%91%E7%94%9F%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%97%B6%EF%BC%8C%E5%93%A8%E5%85%B5%E4%BC%9A%E5%B0%86%E6%9C%80%E6%96%B0%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81%E7%BB%99redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.7.2.1.3.</span> <span class="toc-text">通知：当集群发生故障转移时，哨兵会将最新节点信息推送给redis客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.7.2.1.4.</span> <span class="toc-text">监控原理：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">选举新的master机制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%EF%BC%9A"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">实现故障转移：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">1.7.3.</span> <span class="toc-text">搭建分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">用于解决的问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.3.1.1.</span> <span class="toc-text">海量数据存储问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.3.1.2.</span> <span class="toc-text">高并发写的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">集群特征：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%89%E5%A4%9A%E4%B8%AAmaster%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BF%9D%E5%AD%98%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.3.2.1.</span> <span class="toc-text">集群中有多个master，用于保存不同数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AAmaster%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AAslave%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.3.2.2.</span> <span class="toc-text">每个master都可以有多个slave节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#master%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E4%BA%92%E7%9B%B8ping%E7%9B%91%E6%B5%8B%E5%BD%BC%E6%AD%A4%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81"><span class="toc-number">1.7.3.2.3.</span> <span class="toc-text">master之间可以互相ping监测彼此健康状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisObject"><span class="toc-number">1.7.4.</span> <span class="toc-text">RedisObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SkipList"><span class="toc-number">1.7.5.</span> <span class="toc-text">SkipList:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E9%93%BE%E8%A1%A8%EF%BC%8C%E4%BD%86%E4%B8%8E%E4%BC%A0%E7%BB%9F%E9%93%BE%E8%A1%A8%E6%9C%89%E4%BA%9B%E5%B7%AE%E5%BC%82%EF%BC%9A"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">本质上是链表，但与传统链表有些差异：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%8C%89%E7%85%A7%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">元素按照升序排序存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%AB%E5%A4%9A%E5%B1%82%E6%8C%87%E9%92%88%EF%BC%8C%E6%8C%87%E9%92%88%E8%B7%A8%E5%BA%A6%E4%B8%8D%E5%90%8C"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">节点可能包含多层指针，指针跨度不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%95%88%E7%8E%87%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%B8%80%E8%87%B4%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%AE%80%E5%8D%95"><span class="toc-number">1.7.5.1.3.</span> <span class="toc-text">增删改效率与红黑树基本一致，实现更简单</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedSet"><span class="toc-number">1.7.6.</span> <span class="toc-text">SortedSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">特点：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%8F%E7%BB%84%E6%95%B0%E6%8D%AE%E9%83%BD%E5%8C%85%E5%90%ABscore%E5%92%8Cmember"><span class="toc-number">1.7.6.1.1.</span> <span class="toc-text">每组数据都包含score和member</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#member%E5%94%AF%E4%B8%80"><span class="toc-number">1.7.6.1.2.</span> <span class="toc-text">member唯一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%BE%9D%E6%8D%AEscore%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.6.1.3.</span> <span class="toc-text">可依据score排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">底层数据结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%89%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%94%A8%E4%BA%8E-%E7%94%A8member%E6%9F%A5%E8%AF%A2score-%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AAskipset%E7%94%A8%E4%BA%8E-%E4%BD%BF%E7%94%A8score%E6%9F%A5%E8%AF%A2member"><span class="toc-number">1.7.6.2.1.</span> <span class="toc-text">底层有一个哈希表用于&#x3D;&#x3D;用member查询score&#x3D;&#x3D;，还有一个skipset用于&#x3D;&#x3D;使用score查询member&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%B1%E4%BA%8E%E9%9C%80%E8%A6%81%E7%94%A8score%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%BA%95%E5%B1%82%E6%9C%89%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E8%B7%B3%E8%A1%A8"><span class="toc-number">1.7.6.2.2.</span> <span class="toc-text">由于需要用score来进行排序，因此底层有维护一个跳表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9FKEY%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.7.</span> <span class="toc-text">过期KEY处理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redis%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E5%9C%A8redisDb%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9A"><span class="toc-number">1.7.7.0.1.</span> <span class="toc-text">redis所有数据存放在redisDb结构体中，其中包含两个哈希表：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dict%EF%BC%9A%E4%BF%9D%E5%AD%98redis%E4%B8%AD%E6%89%80%E6%9C%89%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">1.7.7.0.2.</span> <span class="toc-text">dict：保存redis中所有键值对</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#expires%EF%BC%9A%E4%BF%9D%E5%AD%98redis%E4%B8%AD%E6%89%80%E6%9C%89%E8%AE%BE%E7%BD%AE%E4%BA%86%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84key%E5%8F%8A%E5%85%B6%E5%88%B0%E6%9C%9F%E6%97%B6%E9%97%B4-%E5%86%99%E5%85%A5%E6%97%B6%E9%97%B4-TTL"><span class="toc-number">1.7.7.0.3.</span> <span class="toc-text">expires：保存redis中所有设置了过期时间的key及其到期时间(&#x3D;&#x3D;写入时间+TTL&#x3D;&#x3D;)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E6%9C%9Fkey%E7%9A%84%E5%BB%B6%E6%97%B6%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">1.7.7.0.4.</span> <span class="toc-text">过期key的延时删除策略：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%EF%BC%9A%E6%AF%8F%E5%BD%93%E9%9C%80%E8%A6%81%E5%AF%B9%E8%AF%A5key%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%88%A4%E6%96%AD%E8%AF%A5key%E7%9A%84%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4%EF%BC%8C%E5%B7%B2%E7%BB%8F%E8%BF%87%E6%9C%9F%E4%BA%86%E6%89%8D%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.7.0.5.</span> <span class="toc-text">惰性删除：每当需要对该key操作时，会判断该key的存活时间，已经过期了才执行删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E5%88%A0%E9%99%A4%EF%BC%9A%E9%80%9A%E8%BF%87%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E7%9A%84%E6%8A%BD%E6%A0%B7%E9%83%A8%E5%88%86%E6%9C%89TTL%E7%9A%84key%EF%BC%8C%E8%8B%A5%E8%BF%87%E6%9C%9F%E5%88%99%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.7.0.6.</span> <span class="toc-text">周期删除：通过定时任务，周期性的抽样部分有TTL的key，若过期则删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.7.8.</span> <span class="toc-text">内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93redis%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E8%BE%BE%E5%88%B0%E8%AE%BE%E7%BD%AE%E9%98%88%E5%80%BC%E6%97%B6%EF%BC%8C%E4%BC%9A%E4%B8%BB%E5%8A%A8%E6%8C%91%E9%80%89%E9%83%A8%E5%88%86key%E5%88%A0%E9%99%A4%E4%BB%A5%E9%87%8A%E6%94%BE%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AD%98"><span class="toc-number">1.7.8.1.</span> <span class="toc-text">当redis内存使用达到设置阈值时，会主动挑选部分key删除以释放更多内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%B8%A6-volatile-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%86%E6%B7%98%E6%B1%B0%E9%99%90%E5%88%B6%E5%9C%A8%E5%8F%AA%E5%AF%B9%E8%AE%BE%E7%BD%AE%E4%BA%86TTL%E7%9A%84key"><span class="toc-number">1.7.8.2.</span> <span class="toc-text">推荐使用带&#x3D;&#x3D;volatile&#x3D;&#x3D;的过期机制，这样将淘汰限制在只对设置了TTL的key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%B8%A6-LFU-%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BC%9A%E5%87%8F%E5%B0%91%E8%AF%AF%E6%B7%98%E6%B1%B0%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.8.3.</span> <span class="toc-text">推荐使用带&#x3D;&#x3D;LFU&#x3D;&#x3D;的算法，这样会减少误淘汰重要数据</span></a></li></ol></li></ol></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>